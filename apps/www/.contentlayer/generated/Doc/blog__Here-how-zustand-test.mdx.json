{
  "title": "Here is how test-case in Zustand uses ErrorBoundary.\r",
  "published": false,
  "featured": false,
  "component": false,
  "toc": true,
  "body": {
    "raw": "\r\nIn this article, we will analyze ErrorBoundary class component in [Zustand’s test case](https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L378). Error handling is a crucial part of any React application.\r\n\r\n![](https://miro.medium.com/v2/resize:fit:875/1*UEYQKkelOaSQQ9GPxuRHBQ.png)\r\n\r\n# **Overview of the Test Case**\r\n\r\nHere’s the test case we’ll be exploring:\r\n\r\n```plaintext\r\n// Picked from https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L378\r\nit('can throw an error in equality checker', async () => {\r\n  console.error = vi.fn()\r\n  type State = { value: string | number }\r\n\r\n  const initialState: State = { value: 'foo' }\r\n  const useBoundStore = createWithEqualityFn(() => initialState, Object.is)\r\n  const { setState } = useBoundStore\r\n  const selector = (s: State) => s\r\n  const equalityFn = (a: State, b: State) =>\r\n    // @ts-expect-error This function is supposed to throw an error\r\n    a.value.trim() === b.value.trim()\r\n\r\n  class ErrorBoundary extends ClassComponent<\r\n    { children?: ReactNode | undefined },\r\n    { hasError: boolean }\r\n  > {\r\n    constructor(props: { children?: ReactNode | undefined }) {\r\n      super(props)\r\n      this.state = { hasError: false }\r\n    }\r\n    static getDerivedStateFromError() {\r\n      return { hasError: true }\r\n    }\r\n    render() {\r\n      return this.state.hasError ? <div>errored</div> : this.props.children\r\n    }\r\n  }\r\n\r\n  function Component() {\r\n    useBoundStore(selector, equalityFn)\r\n    return <div>no error</div>\r\n  }\r\n\r\n  const { findByText } = render(\r\n    <StrictMode>\r\n      <ErrorBoundary>\r\n        <Component />\r\n      </ErrorBoundary>\r\n    </StrictMode>,\r\n  )\r\n  await findByText('no error')\r\n\r\n  act(() => {\r\n    setState({ value: 123 })\r\n  })\r\n  await findByText('errored')\r\n})\r\n```\r\n\r\nThis test verifies that when an error occurs inside an equality checker, the error is caught and handled gracefully by an `ErrorBoundary` component.\r\n\r\n# **Key Concepts in the Test Case**\r\n\r\n## **1\\. Zustand’s** `createWithEqualityFn`\r\n\r\nZustand allows you to define stores with custom equality functions using `createWithEqualityFn`. In this test, the initial state is defined as:\r\n\r\n```plaintext\r\nconst initialState: State = { value: 'foo' }\r\n```\r\n\r\nThe `createWithEqualityFn` function is used to create a store where the equality function is defined to compare states based on whether the `value` property is equal. In this case, the equality checker is intentionally set to throw an error when `value` is of a type other than `string`:\r\n\r\n> *You can intentionally throw errors in your test cases to ensure your code handles errors as expected.*\r\n\r\n```plaintext\r\nconst equalityFn = (a: State, b: State) =>\r\n  a.value.trim() === b.value.trim() // Throws error if 'value' is not a string\r\n```\r\n\r\nThe test case expects this equality function to fail when `value` becomes a `number`, causing the error handler to come into play.\r\n\r\n## **2\\. Custom** `ErrorBoundary` Component\r\n\r\nReact’s `ErrorBoundary` component is a common pattern used to catch JavaScript errors in a component tree, and Zustand has taken this approach to test how errors within their state management are handled. This particular test case defines a custom `ErrorBoundary` component directly inside the test. I mean, how often do you come across a test case that has the custom ErrorBoundary with in a “test case”?\r\n\r\n```plaintext\r\nclass ErrorBoundary extends ClassComponent<\r\n    { children?: ReactNode | undefined },\r\n    { hasError: boolean }\r\n  > {\r\n    constructor(props: { children?: ReactNode | undefined }) {\r\n      super(props)\r\n      this.state = { hasError: false }\r\n    }\r\n    static getDerivedStateFromError() {\r\n      return { hasError: true }\r\n    }\r\n    render() {\r\n      return this.state.hasError ? <div>errored</div> : this.props.children\r\n    }\r\n  }\r\n```\r\n\r\n**How it works:**\r\n\r\n* The component uses the lifecycle method `getDerivedStateFromError()` to catch errors and update its state (`hasError`) to `true`.\r\n    \r\n* If an error is detected, the component renders `<div>errored</div>`. Otherwise, it renders its children.\r\n    \r\n\r\nIn typical production use, `ErrorBoundary` components are created as reusable elements to catch and display errors across the application. However, embedding the `ErrorBoundary` directly inside a test case like this provides fine-grained control over error testing, allowing you to assert that the component reacts correctly when errors occur in specific parts of the application.\r\n\r\n## **3\\. Testing Error Handling with Vitest**\r\n\r\nIn this test case, Vitest is used as the testing framework. Here’s how it works with Zustand:\r\n\r\n* **Rendering the Component:** The `Component` that uses the `useBoundStore` hook is rendered inside the `ErrorBoundary` within a React `StrictMode` block. This ensures that errors inside the equality checker can be caught.\r\n    \r\n\r\n```plaintext\r\nconst { findByText } = render(\r\n    <StrictMode>\r\n      <ErrorBoundary>\r\n        <Component />\r\n      </ErrorBoundary>\r\n    </StrictMode>,\r\n  )\r\n  await findByText('no error')\r\n```\r\n\r\n* At this point, the test verifies that no error has been thrown yet and checks for the text `no error`.\r\n    \r\n* **Triggering the Error:** After the component is initially rendered without errors, the test triggers an error by updating the store’s state to a `number`:\r\n    \r\n\r\n```plaintext\r\nact(() => {   setState({ value: 123 }) })\r\n```\r\n\r\n* This causes the equality function to throw an error, as `value.trim()` is no longer valid for a `number` type.\r\n    \r\n* **Asserting the Error Handling:** Once the error is thrown, the `ErrorBoundary` catches it, and the test waits for the UI to render the `errored` message:\r\n    \r\n\r\n```plaintext\r\nawait findByText('errored')\r\n```\r\n\r\n* This assertion confirms that the error was properly caught and displayed by the `ErrorBoundary`\r\n    \r\n\r\n# **Why This Approach is Unique**\r\n\r\nWhat makes this test case particularly interesting is the use of an inline `ErrorBoundary` component within a unit test. Typically, error boundaries are part of the main React app, wrapping components in the main render tree. However, Zustand's approach to create an error boundary in the test suite itself offers a more flexible and isolated way to test how errors are handled under specific conditions.\r\n\r\nBy directly controlling the boundary within the test, Zustand ensures:\r\n\r\n1. **Granularity:** The test can focus on how errors in a particular part of the application (like the equality checker) are handled, without needing to rely on global error boundaries.\r\n    \r\n2. **Test Isolation:** The `ErrorBoundary` exists only within the scope of this test, reducing potential side effects or dependencies on the app’s broader error-handling logic.\r\n    \r\n# **About me:**\r\n\r\nHey, my name is Ramu Narasinga. I study large open-source projects and create content about their codebase architecture and best practices, sharing it through articles, videos.\r\n\r\nI am open to work on interesting projects. Send me an email at ramu.narasinga@gmail.com\r\n\r\nMy Github — [https://github.com/ramu-narasinga](https://github.com/ramu-narasinga)\r\n\r\nMy website — [https://ramunarasinga.com](https://ramunarasinga.com/)\r\n\r\nMy Youtube channel — [https://www.youtube.com/@thinkthroo](https://www.youtube.com/@thinkthroo)\r\n\r\nLearning platform — [https://thinkthroo.com](https://thinkthroo.com/)\r\n\r\nCodebase Architecture — [https://app.thinkthroo.com/architecture](https://app.thinkthroo.com/architecture)\r\n\r\nBest practices — [https://app.thinkthroo.com/best-practices](https://app.thinkthroo.com/best-practices)\r\n\r\nProduction-grade projects — [https://app.thinkthroo.com/production-grade-projects](https://app.thinkthroo.com/production-grade-projects)\r\n\r\n# **References:**\r\n\r\n1. [https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L378](https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L378)\r\n    \r\n\r\n[  \r\n](https://medium.com/tag/javascript?source=post_page-----c033d8a38aa8--------------------------------)\r\n",
    "code": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var f=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),N=(r,e)=>{for(var a in e)i(r,a,{get:e[a],enumerable:!0})},c=(r,e,a,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of m(e))!y.call(r,t)&&t!==a&&i(r,t,{get:()=>e[t],enumerable:!(s=u(e,t))||s.enumerable});return r};var b=(r,e,a)=>(a=r!=null?p(g(r)):{},c(e||!r||!r.__esModule?i(a,\"default\",{value:r,enumerable:!0}):a,r)),w=r=>c(i({},\"__esModule\",{value:!0}),r);var d=f((B,l)=>{l.exports=_jsx_runtime});var x={};N(x,{default:()=>o,frontmatter:()=>v});var n=b(d()),v={title:\"Here is how test-case in Zustand uses ErrorBoundary.\"};function h(r){let e={a:\"a\",blockquote:\"blockquote\",br:\"br\",code:\"code\",div:\"div\",em:\"em\",h1:\"h1\",h2:\"h2\",img:\"img\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",span:\"span\",strong:\"strong\",ul:\"ul\",...r.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"In this article, we will analyze ErrorBoundary class component in \",(0,n.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L378\",children:\"Zustand\\u2019s test case\"}),\". Error handling is a crucial part of any React application.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"https://miro.medium.com/v2/resize:fit:875/1*UEYQKkelOaSQQ9GPxuRHBQ.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.h1,{id:\"overview-of-the-test-case\",children:(0,n.jsx)(e.strong,{children:\"Overview of the Test Case\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Here\\u2019s the test case we\\u2019ll be exploring:\"}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"// Picked from https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L378\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"it('can throw an error in equality checker', async () => {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  console.error = vi.fn()\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  type State = { value: string | number }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const initialState: State = { value: 'foo' }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const useBoundStore = createWithEqualityFn(() => initialState, Object.is)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const { setState } = useBoundStore\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const selector = (s: State) => s\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const equalityFn = (a: State, b: State) =>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    // @ts-expect-error This function is supposed to throw an error\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    a.value.trim() === b.value.trim()\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  class ErrorBoundary extends ClassComponent<\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    { children?: ReactNode | undefined },\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    { hasError: boolean }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  > {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    constructor(props: { children?: ReactNode | undefined }) {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      super(props)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      this.state = { hasError: false }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    static getDerivedStateFromError() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      return { hasError: true }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    render() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      return this.state.hasError ? <div>errored</div> : this.props.children\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  function Component() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    useBoundStore(selector, equalityFn)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    return <div>no error</div>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const { findByText } = render(\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    <StrictMode>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      <ErrorBoundary>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"        <Component />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      </ErrorBoundary>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    </StrictMode>,\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  )\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  await findByText('no error')\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  act(() => {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    setState({ value: 123 })\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  })\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  await findByText('errored')\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"})\"})})]})})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This test verifies that when an error occurs inside an equality checker, the error is caught and handled gracefully by an \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" component.\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"key-concepts-in-the-test-case\",children:(0,n.jsx)(e.strong,{children:\"Key Concepts in the Test Case\"})}),`\n`,(0,n.jsxs)(e.h2,{id:\"1-zustands-createwithequalityfn\",children:[(0,n.jsx)(e.strong,{children:\"1. Zustand\\u2019s\"}),\" \",(0,n.jsx)(e.code,{children:\"createWithEqualityFn\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Zustand allows you to define stores with custom equality functions using \",(0,n.jsx)(e.code,{children:\"createWithEqualityFn\"}),\". In this test, the initial state is defined as:\"]}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsx)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"const initialState: State = { value: 'foo' }\"})})})})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"createWithEqualityFn\"}),\" function is used to create a store where the equality function is defined to compare states based on whether the \",(0,n.jsx)(e.code,{children:\"value\"}),\" property is equal. In this case, the equality checker is intentionally set to throw an error when \",(0,n.jsx)(e.code,{children:\"value\"}),\" is of a type other than \",(0,n.jsx)(e.code,{children:\"string\"}),\":\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"You can intentionally throw errors in your test cases to ensure your code handles errors as expected.\"})}),`\n`]}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"const equalityFn = (a: State, b: State) =>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  a.value.trim() === b.value.trim() // Throws error if 'value' is not a string\"})})]})})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The test case expects this equality function to fail when \",(0,n.jsx)(e.code,{children:\"value\"}),\" becomes a \",(0,n.jsx)(e.code,{children:\"number\"}),\", causing the error handler to come into play.\"]}),`\n`,(0,n.jsxs)(e.h2,{id:\"2-custom-errorboundary-component\",children:[(0,n.jsx)(e.strong,{children:\"2. Custom\"}),\" \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" Component\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"React\\u2019s \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" component is a common pattern used to catch JavaScript errors in a component tree, and Zustand has taken this approach to test how errors within their state management are handled. This particular test case defines a custom \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" component directly inside the test. I mean, how often do you come across a test case that has the custom ErrorBoundary with in a \\u201Ctest case\\u201D?\"]}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"class ErrorBoundary extends ClassComponent<\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    { children?: ReactNode | undefined },\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    { hasError: boolean }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  > {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    constructor(props: { children?: ReactNode | undefined }) {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      super(props)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      this.state = { hasError: false }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    static getDerivedStateFromError() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      return { hasError: true }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    render() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      return this.state.hasError ? <div>errored</div> : this.props.children\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  }\"})})]})})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"How it works:\"})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"The component uses the lifecycle method \",(0,n.jsx)(e.code,{children:\"getDerivedStateFromError()\"}),\" to catch errors and update its state (\",(0,n.jsx)(e.code,{children:\"hasError\"}),\") to \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"If an error is detected, the component renders \",(0,n.jsx)(e.code,{children:\"<div>errored</div>\"}),\". Otherwise, it renders its children.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In typical production use, \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" components are created as reusable elements to catch and display errors across the application. However, embedding the \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" directly inside a test case like this provides fine-grained control over error testing, allowing you to assert that the component reacts correctly when errors occur in specific parts of the application.\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"3-testing-error-handling-with-vitest\",children:(0,n.jsx)(e.strong,{children:\"3. Testing Error Handling with Vitest\"})}),`\n`,(0,n.jsx)(e.p,{children:\"In this test case, Vitest is used as the testing framework. Here\\u2019s how it works with Zustand:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Rendering the Component:\"}),\" The \",(0,n.jsx)(e.code,{children:\"Component\"}),\" that uses the \",(0,n.jsx)(e.code,{children:\"useBoundStore\"}),\" hook is rendered inside the \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" within a React \",(0,n.jsx)(e.code,{children:\"StrictMode\"}),\" block. This ensures that errors inside the equality checker can be caught.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"const { findByText } = render(\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    <StrictMode>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      <ErrorBoundary>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"        <Component />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      </ErrorBoundary>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    </StrictMode>,\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  )\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  await findByText('no error')\"})})]})})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"At this point, the test verifies that no error has been thrown yet and checks for the text \",(0,n.jsx)(e.code,{children:\"no error\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Triggering the Error:\"}),\" After the component is initially rendered without errors, the test triggers an error by updating the store\\u2019s state to a \",(0,n.jsx)(e.code,{children:\"number\"}),\":\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsx)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"act(() => {   setState({ value: 123 }) })\"})})})})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"This causes the equality function to throw an error, as \",(0,n.jsx)(e.code,{children:\"value.trim()\"}),\" is no longer valid for a \",(0,n.jsx)(e.code,{children:\"number\"}),\" type.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Asserting the Error Handling:\"}),\" Once the error is thrown, the \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" catches it, and the test waits for the UI to render the \",(0,n.jsx)(e.code,{children:\"errored\"}),\" message:\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsx)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"await findByText('errored')\"})})})})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"This assertion confirms that the error was properly caught and displayed by the \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"})]}),`\n`]}),`\n`,(0,n.jsx)(e.h1,{id:\"why-this-approach-is-unique\",children:(0,n.jsx)(e.strong,{children:\"Why This Approach is Unique\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"What makes this test case particularly interesting is the use of an inline \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" component within a unit test. Typically, error boundaries are part of the main React app, wrapping components in the main render tree. However, Zustand's approach to create an error boundary in the test suite itself offers a more flexible and isolated way to test how errors are handled under specific conditions.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"By directly controlling the boundary within the test, Zustand ensures:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Granularity:\"}),\" The test can focus on how errors in a particular part of the application (like the equality checker) are handled, without needing to rely on global error boundaries.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Test Isolation:\"}),\" The \",(0,n.jsx)(e.code,{children:\"ErrorBoundary\"}),\" exists only within the scope of this test, reducing potential side effects or dependencies on the app\\u2019s broader error-handling logic.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h1,{id:\"about-me\",children:(0,n.jsx)(e.strong,{children:\"About me:\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Hey, my name is Ramu Narasinga. I study large open-source projects and create content about their codebase architecture and best practices, sharing it through articles, videos.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"I am open to work on interesting projects. Send me an email at \",(0,n.jsx)(e.a,{href:\"mailto:ramu.narasinga@gmail.com\",children:\"ramu.narasinga@gmail.com\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"My Github \\u2014 \",(0,n.jsx)(e.a,{href:\"https://github.com/ramu-narasinga\",children:\"https://github.com/ramu-narasinga\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"My website \\u2014 \",(0,n.jsx)(e.a,{href:\"https://ramunarasinga.com/\",children:\"https://ramunarasinga.com\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"My Youtube channel \\u2014 \",(0,n.jsx)(e.a,{href:\"https://www.youtube.com/@thinkthroo\",children:\"https://www.youtube.com/@thinkthroo\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Learning platform \\u2014 \",(0,n.jsx)(e.a,{href:\"https://thinkthroo.com/\",children:\"https://thinkthroo.com\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Codebase Architecture \\u2014 \",(0,n.jsx)(e.a,{href:\"https://app.thinkthroo.com/architecture\",children:\"https://app.thinkthroo.com/architecture\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Best practices \\u2014 \",(0,n.jsx)(e.a,{href:\"https://app.thinkthroo.com/best-practices\",children:\"https://app.thinkthroo.com/best-practices\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Production-grade projects \\u2014 \",(0,n.jsx)(e.a,{href:\"https://app.thinkthroo.com/production-grade-projects\",children:\"https://app.thinkthroo.com/production-grade-projects\"})]}),`\n`,(0,n.jsx)(e.h1,{id:\"references\",children:(0,n.jsx)(e.strong,{children:\"References:\"})}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L378\",children:\"https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L378\"})}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.a,{href:\"https://medium.com/tag/javascript?source=post_page-----c033d8a38aa8--------------------------------\",children:[(0,n.jsx)(e.br,{}),`\n`]})})]})}function o(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,{...r,children:(0,n.jsx)(h,{...r})}):h(r)}return w(x);})();\n;return Component;"
  },
  "_id": "blog/Here-how-zustand-test.mdx",
  "_raw": {
    "sourceFilePath": "blog/Here-how-zustand-test.mdx",
    "sourceFileName": "Here-how-zustand-test.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/Here-how-zustand-test"
  },
  "type": "Doc",
  "slug": "/blog/Here-how-zustand-test",
  "slugAsParams": "Here-how-zustand-test"
}