{
  "title": "Add a test case when your open-source project’s issue is fixed.\r",
  "published": false,
  "featured": false,
  "component": false,
  "toc": true,
  "body": {
    "raw": "\r\nBuilding a stable project is hard and time consuming. When you open source that project, reliability and stability is important because you need to establish that trust and authority. As your open source project evolves and new features are introduced, regressions (bugs that reappear) can sneak back into the code. To prevent this, it is important to add test cases whenever an issue is fixed. These test cases act as a safety net, ensuring that future changes don’t reintroduce old bugs.\r\n\r\nIn this article, we’ll explore the importance of adding test cases for bug fixes by examining two issues from Zustand’s repository — [**Issue #84**](https://github.com/pmndrs/zustand/issues/84) and [**Issue #86**](https://github.com/pmndrs/zustand/issues/86). Zustand, a popular state management library for React, experienced these bugs in its subscription management. Both issues were subtle but critical, and writing test cases for them ensures they won’t surface again in future releases.\r\n\r\nMind you, these issues were reported on Zustand’s version — 2.2.1. Link to codesandbox: [https://codesandbox.io/s/quirky-taussig-ng90m](https://codesandbox.io/s/quirky-taussig-ng90m)\r\n\r\n![](https://miro.medium.com/v2/resize:fit:875/1*49_ts2DhjaXfW0wgY3UVwQ.png)\r\n\r\nThe latest stable Zustand’s version is 4.5.5 but it’s good to learn what it means to add test cases to the bugs fixed after they were reported.\r\n\r\n# **Why Should You Add a Test Case After Fixing a Bug?**\r\n\r\nWhen an issue is reported and fixed in a codebase, it’s tempting to move on after the fix. But without a dedicated test case that reproduces the problem, there is no guarantee that the issue won’t recur in future updates. Even if the code seems stable after the fix, new features or refactors can sometimes undo the correction.\r\n\r\nHere’s why it’s crucial to add a test case after each bug fix:\r\n\r\n1. **Prevents Regressions:** As the code evolves, automated tests ensure that past issues don’t creep back in.\r\n    \r\n2. **Serves as Documentation:** Test cases provide clear examples of what was fixed and how the software should behave under similar conditions.\r\n    \r\n3. **Confidence in Future Development:** Contributors can confidently make changes, knowing that tests will catch any breaks.\r\n    \r\n\r\nNow, let’s look at real-world examples from Zustand’s codebase and see how test cases were added after issues #84 and #86 were fixed.\r\n\r\n# **Issue #84: Subscribers Can Be Corrupted During State Updates**\r\n\r\n## **Background**\r\n\r\nThe bug reported in [Issue #84](https://github.com/pmndrs/zustand/issues/84) revolved around Zustand’s subscription system. Under certain conditions, subscribers could be “orphaned” — meaning components subscribing to the store would stop receiving updates.\r\n\r\nWhen state updates happened during the component lifecycle (e.g., unmounts or re-renders), the array of subscribers could be corrupted. This caused a component that had subscribed to the store to never get updates, as its listener was overwritten by another subscriber.\r\n\r\nSubscribers are a Set. Here’s a proof from Zustand’s source code related to createStore\r\n\r\n![](https://miro.medium.com/v2/resize:fit:875/1*uN5rluQSzLdC3RYlvVch-w.png)\r\n\r\n![](https://miro.medium.com/v2/resize:fit:875/1*_rfjvuNlw31UfAZeX3Bmsg.png)\r\n\r\n## **Test Case for Fixing Issue #84**\r\n\r\nAfter fixing this issue, Zustand added a test case to ensure the correct subscriber is removed on unmount:\r\n\r\n```plaintext\r\n// https://github.com/pmndrs/zustand/issues/84\r\nit('ensures the correct subscriber is removed on unmount', async () => {\r\n  const useBoundStore = create(() => ({ count: 0 }))\r\n  const api = useBoundStore\r\n\r\n  function increment() {\r\n    api.setState(({ count }) => ({ count: count + 1 }))\r\n  }\r\n\r\n  function Count() {\r\n    const c = useBoundStore((s) => s.count)\r\n    return <div>count: {c}</div>\r\n  }\r\n\r\n  function CountWithInitialIncrement() {\r\n    useLayoutEffect(increment, [])\r\n    return <Count />\r\n  }\r\n\r\n  function Component() {\r\n    const [Counter, setCounter] = useState(() => CountWithInitialIncrement)\r\n    useLayoutEffect(() => {\r\n      setCounter(() => Count)\r\n    }, [])\r\n    return (\r\n      <>\r\n        <Counter />\r\n        <Count />\r\n      </>\r\n    )\r\n  }\r\n\r\n  const { findAllByText } = render(\r\n    <>\r\n      <Component />\r\n    </>,\r\n  )\r\n\r\n  expect((await findAllByText('count: 1')).length).toBe(2)\r\n\r\n  act(increment)\r\n\r\n  expect((await findAllByText('count: 2')).length).toBe(2)\r\n})\r\n```\r\n\r\nThis test checks that the correct subscriber is removed when components unmount and ensures the subscription system functions as expected. Here’s what happens in the test:\r\n\r\n* A store is created with an initial `count` of `0`.\r\n    \r\n* Components subscribe to the `count` state.\r\n    \r\n* The `increment` function is called when the component mounts, increasing the `count`.\r\n    \r\n* After unmounting and mounting components, the test ensures that the right subscribers are removed and that the state update propagates correctly to the components still mounted.\r\n    \r\n\r\nThis ensures the original bug, where subscribers would be corrupted during the lifecycle, does not reoccur.\r\n\r\n# **Issue #86: Subscribers Overwritten on Component Remount**\r\n\r\n## **Background**\r\n\r\nIn [Issue #86](https://github.com/pmndrs/zustand/issues/86), an issue was reported where subscribers would stop receiving updates after components remounted. This happened because subscribers in Zustand were being overwritten with the same index when switching between mounted components.\r\n\r\nThe issue boiled down to a problem in managing multiple subscribers — each subscriber was assigned an index, and when a new component subscribed, the indices could conflict. This caused one subscriber to overwrite another, leading to components not receiving state updates after a remount.\r\n\r\n## **Test Case for Fixing Issue #86**\r\n\r\nHere’s the test case added after fixing this issue:\r\n\r\n```plaintext\r\n// https://github.com/pmndrs/zustand/issues/86\r\nit('ensures a subscriber is not mistakenly overwritten', async () => {\r\n  const useBoundStore = create(() => ({ count: 0 }))\r\n  const { setState } = useBoundStore\r\n\r\n  function Count1() {\r\n    const c = useBoundStore((s) => s.count)\r\n    return <div>count1: {c}</div>\r\n  }\r\n\r\n  function Count2() {\r\n    const c = useBoundStore((s) => s.count)\r\n    return <div>count2: {c}</div>\r\n  }\r\n\r\n  // Add 1st subscriber.\r\n  const { findAllByText, rerender } = render(\r\n    <StrictMode>\r\n      <Count1 />\r\n    </StrictMode>,\r\n  )\r\n\r\n  // Replace 1st subscriber with another.\r\n  rerender(\r\n    <StrictMode>\r\n      <Count2 />\r\n    </StrictMode>,\r\n  )\r\n\r\n  // Add 2 additional subscribers.\r\n  rerender(\r\n    <StrictMode>\r\n      <Count2 />\r\n      <Count1 />\r\n      <Count1 />\r\n    </StrictMode>,\r\n  )\r\n\r\n  // Call all subscribers\r\n  act(() => setState({ count: 1 }))\r\n\r\n  expect((await findAllByText('count1: 1')).length).toBe(2)\r\n  expect((await findAllByText('count2: 1')).length).toBe(1)\r\n})\r\n```\r\n\r\nThis test ensures that:\r\n\r\n* Subscribers are not overwritten when components are mounted and unmounted.\r\n    \r\n* Multiple components can subscribe to the same store without conflict.\r\n    \r\n* When the state changes, all subscribed components update correctly.\r\n    \r\n\r\nBy testing for the correct number of `count1` and `count2` components receiving updates, the test guarantees that the fix for this issue works and won't regress in future versions of Zustand.\r\n\r\n# **Lesson here is — “Ensure Stability with Tests”**\r\n\r\nThese two examples from Zustand illustrate why it is essential to add test cases after fixing bugs in an open-source project. They help ensure:\r\n\r\n* The original bug is fixed.\r\n    \r\n* Future changes do not break the fix.\r\n    \r\n* Contributors can refactor, add features, or improve performance without worrying about breaking functionality that was previously addressed.\r\n    \r\n\r\nBy writing test cases after bug fixes, you contribute to the long-term health of the project, helping both maintainers and users trust that the project is stable and well-maintained.\r\n\r\n# **Conclusion**\r\n\r\nAdding test cases after fixing bugs is a crucial habit for maintaining the integrity of your open-source project. As demonstrated in Zustand’s handling of Issues #84 and #86, these test cases help catch potential regressions and ensure the system behaves as expected in real-world scenarios.\r\n\r\nSo, the next time you fix a bug in your open-source project, don’t stop at the fix. Add a test case to ensure the issue is gone for good, safeguarding your project’s future stability.\r\n\r\n# **About me:**\r\n\r\nHey, my name is Ramu Narasinga. I study large open-source projects and create content about their codebase architecture and best practices, sharing it through articles, videos.\r\n\r\nI am open to work on interesting projects. Send me an email at ramu.narasinga@gmail.com\r\n\r\nMy Github — [https://github.com/ramu-narasinga](https://github.com/ramu-narasinga)\r\n\r\nMy website — [https://ramunarasinga.com](https://ramunarasinga.com/)\r\n\r\nMy Youtube channel — [https://www.youtube.com/@thinkthroo](https://www.youtube.com/@thinkthroo)\r\n\r\nLearning platform — [https://thinkthroo.com](https://thinkthroo.com/)\r\n\r\nCodebase Architecture — [https://app.thinkthroo.com/architecture](https://app.thinkthroo.com/architecture)\r\n\r\nBest practices — [https://app.thinkthroo.com/best-practices](https://app.thinkthroo.com/best-practices)\r\n\r\nProduction-grade projects — [https://app.thinkthroo.com/production-grade-projects](https://app.thinkthroo.com/production-grade-projects)\r\n\r\n# **References:**\r\n\r\n1. [https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L628](https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L628)\r\n    \r\n2. [https://github.com/pmndrs/zustand/issues/86](https://github.com/pmndrs/zustand/issues/86)\r\n    \r\n3. [https://github.com/pmndrs/zustand/blob/v4.5.5/src/vanilla.ts#L89](https://github.com/pmndrs/zustand/blob/v4.5.5/src/vanilla.ts#L89)\r\n    \r\n4. [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\\_Objects/Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\r\n",
    "code": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports),N=(s,e)=>{for(var t in e)a(s,t,{get:e[t],enumerable:!0})},c=(s,e,t,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!b.call(s,i)&&i!==t&&a(s,i,{get:()=>e[i],enumerable:!(r=u(e,i))||r.enumerable});return s};var w=(s,e,t)=>(t=s!=null?p(g(s)):{},c(e||!s||!s.__esModule?a(t,\"default\",{value:s,enumerable:!0}):t,s)),y=s=>c(a({},\"__esModule\",{value:!0}),s);var d=f((C,l)=>{l.exports=_jsx_runtime});var v={};N(v,{default:()=>o,frontmatter:()=>x});var n=w(d()),x={title:\"Add a test case when your open-source project\\u2019s issue is fixed.\"};function h(s){let e={a:\"a\",code:\"code\",div:\"div\",h1:\"h1\",h2:\"h2\",img:\"img\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",span:\"span\",strong:\"strong\",ul:\"ul\",...s.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Building a stable project is hard and time consuming. When you open source that project, reliability and stability is important because you need to establish that trust and authority. As your open source project evolves and new features are introduced, regressions (bugs that reappear) can sneak back into the code. To prevent this, it is important to add test cases whenever an issue is fixed. These test cases act as a safety net, ensuring that future changes don\\u2019t reintroduce old bugs.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this article, we\\u2019ll explore the importance of adding test cases for bug fixes by examining two issues from Zustand\\u2019s repository \\u2014 \",(0,n.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/issues/84\",children:(0,n.jsx)(e.strong,{children:\"Issue #84\"})}),\" and \",(0,n.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/issues/86\",children:(0,n.jsx)(e.strong,{children:\"Issue #86\"})}),\". Zustand, a popular state management library for React, experienced these bugs in its subscription management. Both issues were subtle but critical, and writing test cases for them ensures they won\\u2019t surface again in future releases.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Mind you, these issues were reported on Zustand\\u2019s version \\u2014 2.2.1. Link to codesandbox: \",(0,n.jsx)(e.a,{href:\"https://codesandbox.io/s/quirky-taussig-ng90m\",children:\"https://codesandbox.io/s/quirky-taussig-ng90m\"})]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"https://miro.medium.com/v2/resize:fit:875/1*49_ts2DhjaXfW0wgY3UVwQ.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"The latest stable Zustand\\u2019s version is 4.5.5 but it\\u2019s good to learn what it means to add test cases to the bugs fixed after they were reported.\"}),`\n`,(0,n.jsx)(e.h1,{id:\"why-should-you-add-a-test-case-after-fixing-a-bug\",children:(0,n.jsx)(e.strong,{children:\"Why Should You Add a Test Case After Fixing a Bug?\"})}),`\n`,(0,n.jsx)(e.p,{children:\"When an issue is reported and fixed in a codebase, it\\u2019s tempting to move on after the fix. But without a dedicated test case that reproduces the problem, there is no guarantee that the issue won\\u2019t recur in future updates. Even if the code seems stable after the fix, new features or refactors can sometimes undo the correction.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here\\u2019s why it\\u2019s crucial to add a test case after each bug fix:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Prevents Regressions:\"}),\" As the code evolves, automated tests ensure that past issues don\\u2019t creep back in.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Serves as Documentation:\"}),\" Test cases provide clear examples of what was fixed and how the software should behave under similar conditions.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Confidence in Future Development:\"}),\" Contributors can confidently make changes, knowing that tests will catch any breaks.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Now, let\\u2019s look at real-world examples from Zustand\\u2019s codebase and see how test cases were added after issues #84 and #86 were fixed.\"}),`\n`,(0,n.jsx)(e.h1,{id:\"issue-84-subscribers-can-be-corrupted-during-state-updates\",children:(0,n.jsx)(e.strong,{children:\"Issue #84: Subscribers Can Be Corrupted During State Updates\"})}),`\n`,(0,n.jsx)(e.h2,{id:\"background\",children:(0,n.jsx)(e.strong,{children:\"Background\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The bug reported in \",(0,n.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/issues/84\",children:\"Issue #84\"}),\" revolved around Zustand\\u2019s subscription system. Under certain conditions, subscribers could be \\u201Corphaned\\u201D \\u2014 meaning components subscribing to the store would stop receiving updates.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"When state updates happened during the component lifecycle (e.g., unmounts or re-renders), the array of subscribers could be corrupted. This caused a component that had subscribed to the store to never get updates, as its listener was overwritten by another subscriber.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Subscribers are a Set. Here\\u2019s a proof from Zustand\\u2019s source code related to createStore\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"https://miro.medium.com/v2/resize:fit:875/1*uN5rluQSzLdC3RYlvVch-w.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"https://miro.medium.com/v2/resize:fit:875/1*_rfjvuNlw31UfAZeX3Bmsg.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.h2,{id:\"test-case-for-fixing-issue-84\",children:(0,n.jsx)(e.strong,{children:\"Test Case for Fixing Issue #84\"})}),`\n`,(0,n.jsx)(e.p,{children:\"After fixing this issue, Zustand added a test case to ensure the correct subscriber is removed on unmount:\"}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"// https://github.com/pmndrs/zustand/issues/84\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"it('ensures the correct subscriber is removed on unmount', async () => {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const useBoundStore = create(() => ({ count: 0 }))\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const api = useBoundStore\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  function increment() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    api.setState(({ count }) => ({ count: count + 1 }))\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  function Count() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    const c = useBoundStore((s) => s.count)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    return <div>count: {c}</div>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  function CountWithInitialIncrement() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    useLayoutEffect(increment, [])\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    return <Count />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  function Component() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    const [Counter, setCounter] = useState(() => CountWithInitialIncrement)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    useLayoutEffect(() => {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      setCounter(() => Count)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    }, [])\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    return (\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      <>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"        <Counter />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"        <Count />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      </>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    )\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const { findAllByText } = render(\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    <>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      <Component />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    </>,\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  )\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  expect((await findAllByText('count: 1')).length).toBe(2)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  act(increment)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  expect((await findAllByText('count: 2')).length).toBe(2)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"})\"})})]})})}),`\n`,(0,n.jsx)(e.p,{children:\"This test checks that the correct subscriber is removed when components unmount and ensures the subscription system functions as expected. Here\\u2019s what happens in the test:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"A store is created with an initial \",(0,n.jsx)(e.code,{children:\"count\"}),\" of \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Components subscribe to the \",(0,n.jsx)(e.code,{children:\"count\"}),\" state.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"increment\"}),\" function is called when the component mounts, increasing the \",(0,n.jsx)(e.code,{children:\"count\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"After unmounting and mounting components, the test ensures that the right subscribers are removed and that the state update propagates correctly to the components still mounted.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"This ensures the original bug, where subscribers would be corrupted during the lifecycle, does not reoccur.\"}),`\n`,(0,n.jsx)(e.h1,{id:\"issue-86-subscribers-overwritten-on-component-remount\",children:(0,n.jsx)(e.strong,{children:\"Issue #86: Subscribers Overwritten on Component Remount\"})}),`\n`,(0,n.jsx)(e.h2,{id:\"background-1\",children:(0,n.jsx)(e.strong,{children:\"Background\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In \",(0,n.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/issues/86\",children:\"Issue #86\"}),\", an issue was reported where subscribers would stop receiving updates after components remounted. This happened because subscribers in Zustand were being overwritten with the same index when switching between mounted components.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The issue boiled down to a problem in managing multiple subscribers \\u2014 each subscriber was assigned an index, and when a new component subscribed, the indices could conflict. This caused one subscriber to overwrite another, leading to components not receiving state updates after a remount.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"test-case-for-fixing-issue-86\",children:(0,n.jsx)(e.strong,{children:\"Test Case for Fixing Issue #86\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Here\\u2019s the test case added after fixing this issue:\"}),`\n`,(0,n.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,n.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,n.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"// https://github.com/pmndrs/zustand/issues/86\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"it('ensures a subscriber is not mistakenly overwritten', async () => {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const useBoundStore = create(() => ({ count: 0 }))\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const { setState } = useBoundStore\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  function Count1() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    const c = useBoundStore((s) => s.count)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    return <div>count1: {c}</div>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  function Count2() {\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    const c = useBoundStore((s) => s.count)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    return <div>count2: {c}</div>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  }\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  // Add 1st subscriber.\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  const { findAllByText, rerender } = render(\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    <StrictMode>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      <Count1 />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    </StrictMode>,\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  )\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  // Replace 1st subscriber with another.\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  rerender(\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    <StrictMode>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      <Count2 />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    </StrictMode>,\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  )\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  // Add 2 additional subscribers.\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  rerender(\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    <StrictMode>\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      <Count2 />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      <Count1 />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"      <Count1 />\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"    </StrictMode>,\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  )\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  // Call all subscribers\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  act(() => setState({ count: 1 }))\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  expect((await findAllByText('count1: 1')).length).toBe(2)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"  expect((await findAllByText('count2: 1')).length).toBe(1)\"})}),`\n`,(0,n.jsx)(e.span,{className:\"line\",children:(0,n.jsx)(e.span,{children:\"})\"})})]})})}),`\n`,(0,n.jsx)(e.p,{children:\"This test ensures that:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Subscribers are not overwritten when components are mounted and unmounted.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Multiple components can subscribe to the same store without conflict.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"When the state changes, all subscribed components update correctly.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"By testing for the correct number of \",(0,n.jsx)(e.code,{children:\"count1\"}),\" and \",(0,n.jsx)(e.code,{children:\"count2\"}),\" components receiving updates, the test guarantees that the fix for this issue works and won't regress in future versions of Zustand.\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"lesson-here-is--ensure-stability-with-tests\",children:(0,n.jsx)(e.strong,{children:\"Lesson here is \\u2014 \\u201CEnsure Stability with Tests\\u201D\"})}),`\n`,(0,n.jsx)(e.p,{children:\"These two examples from Zustand illustrate why it is essential to add test cases after fixing bugs in an open-source project. They help ensure:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"The original bug is fixed.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Future changes do not break the fix.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Contributors can refactor, add features, or improve performance without worrying about breaking functionality that was previously addressed.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"By writing test cases after bug fixes, you contribute to the long-term health of the project, helping both maintainers and users trust that the project is stable and well-maintained.\"}),`\n`,(0,n.jsx)(e.h1,{id:\"conclusion\",children:(0,n.jsx)(e.strong,{children:\"Conclusion\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Adding test cases after fixing bugs is a crucial habit for maintaining the integrity of your open-source project. As demonstrated in Zustand\\u2019s handling of Issues #84 and #86, these test cases help catch potential regressions and ensure the system behaves as expected in real-world scenarios.\"}),`\n`,(0,n.jsx)(e.p,{children:\"So, the next time you fix a bug in your open-source project, don\\u2019t stop at the fix. Add a test case to ensure the issue is gone for good, safeguarding your project\\u2019s future stability.\"}),`\n`,(0,n.jsx)(e.h1,{id:\"about-me\",children:(0,n.jsx)(e.strong,{children:\"About me:\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Hey, my name is Ramu Narasinga. I study large open-source projects and create content about their codebase architecture and best practices, sharing it through articles, videos.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"I am open to work on interesting projects. Send me an email at \",(0,n.jsx)(e.a,{href:\"mailto:ramu.narasinga@gmail.com\",children:\"ramu.narasinga@gmail.com\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"My Github \\u2014 \",(0,n.jsx)(e.a,{href:\"https://github.com/ramu-narasinga\",children:\"https://github.com/ramu-narasinga\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"My website \\u2014 \",(0,n.jsx)(e.a,{href:\"https://ramunarasinga.com/\",children:\"https://ramunarasinga.com\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"My Youtube channel \\u2014 \",(0,n.jsx)(e.a,{href:\"https://www.youtube.com/@thinkthroo\",children:\"https://www.youtube.com/@thinkthroo\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Learning platform \\u2014 \",(0,n.jsx)(e.a,{href:\"https://thinkthroo.com/\",children:\"https://thinkthroo.com\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Codebase Architecture \\u2014 \",(0,n.jsx)(e.a,{href:\"https://app.thinkthroo.com/architecture\",children:\"https://app.thinkthroo.com/architecture\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Best practices \\u2014 \",(0,n.jsx)(e.a,{href:\"https://app.thinkthroo.com/best-practices\",children:\"https://app.thinkthroo.com/best-practices\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Production-grade projects \\u2014 \",(0,n.jsx)(e.a,{href:\"https://app.thinkthroo.com/production-grade-projects\",children:\"https://app.thinkthroo.com/production-grade-projects\"})]}),`\n`,(0,n.jsx)(e.h1,{id:\"references\",children:(0,n.jsx)(e.strong,{children:\"References:\"})}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L628\",children:\"https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L628\"})}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/issues/86\",children:\"https://github.com/pmndrs/zustand/issues/86\"})}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/blob/v4.5.5/src/vanilla.ts#L89\",children:\"https://github.com/pmndrs/zustand/blob/v4.5.5/src/vanilla.ts#L89\"})}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\",children:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\"})}),`\n`]}),`\n`]})]})}function o(s={}){let{wrapper:e}=s.components||{};return e?(0,n.jsx)(e,{...s,children:(0,n.jsx)(h,{...s})}):h(s)}return y(v);})();\n;return Component;"
  },
  "_id": "blog/add-a-test-case.mdx",
  "_raw": {
    "sourceFilePath": "blog/add-a-test-case.mdx",
    "sourceFileName": "add-a-test-case.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/add-a-test-case"
  },
  "type": "Doc",
  "slug": "/blog/add-a-test-case",
  "slugAsParams": "add-a-test-case"
}