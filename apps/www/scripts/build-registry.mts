import {
    Registry,
    registryItemSchema,
    registryItemTypeSchema,
    registrySchema,
} from "thinkthroo/registry"
import { registry } from "../registry"
import { tmpdir } from "os"
import path from "path"
import { rimraf } from "rimraf"
import { existsSync, promises as fs } from "fs"
import { generators } from "../registry/registry-generators"
import z from "zod"
import { Project, ScriptKind } from "ts-morph"

const REGISTRY_PATH = path.join(process.cwd(), "public/r")

const REGISTRY_INDEX_WHITELIST: z.infer<typeof registryItemTypeSchema>[] = [
    "registry:generator"
]

const project = new Project({
    compilerOptions: {},
})

async function createTempSourceFile(filename: string) {
    const dir = await fs.mkdtemp(path.join(tmpdir(), "shadcn-"))
    return path.join(dir, filename)
}

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
    let index = `// @ts-nocheck
  // This file is autogenerated by scripts/build-registry.ts
  // Do not edit this file directly.
  import * as React from "react"
  
  export const Index: Record<string, any> = {
  `

    for (const generator of generators) {
        index += `  "${generator.name}": {`

        // Build generator index.
        for (const item of registry.items) {
            const resolveFiles = item.files?.map(
                (file) =>
                    `registry/${generator.name}/${typeof file === "string" ? file : file.path
                    }`
            )
            if (!resolveFiles) {
                continue
            }

            const type = item.type.split(":")[1]
            let sourceFilename = ""

            index += `
      "${item.name}": {
        name: "${item.name}",
        description: "${item.description ?? ""}",
        type: "${item.type}",
        registryDependencies: ${JSON.stringify(item.registryDependencies)},
        files: [${item.files?.map((file) => {
                const filePath = `registry/${generator.name}/${typeof file === "string" ? file : file.path
                    }`
                const resolvedFilePath = path.resolve(filePath)
                return typeof file === "string"
                    ? `"${resolvedFilePath}"`
                    : `{
          path: "${filePath}",
          type: "${file.type}",
          target: "${file.target ?? ""}"
        }`
            })}],
        source: "${sourceFilename}",
        meta: ${JSON.stringify(item.meta)},
      },`
        }

        index += `
    },`
    }

    index += `
  }
  `

    // ----------------------------------------------------------------------------
    // Build registry/index.json.
    // ----------------------------------------------------------------------------
    const items = registry.items
        .filter((item) => ["registry:generator"].includes(item.type))
        .map((item) => {
            return {
                ...item,
                files: item.files?.map((_file) => {
                    const file =
                        typeof _file === "string"
                            ? {
                                path: _file,
                                type: item.type,
                            }
                            : _file

                    return file
                }),
            }
        })
    const registryJson = JSON.stringify(items, null, 2)
    rimraf.sync(path.join(REGISTRY_PATH, "index.json"))
    await fs.writeFile(
        path.join(REGISTRY_PATH, "index.json"),
        registryJson,
        "utf8"
    )

    // Write generator index.
    rimraf.sync(path.join(process.cwd(), "__registry__/index.tsx"))
    await fs.writeFile(path.join(process.cwd(), "__registry__/index.tsx"), index)
}

// ----------------------------------------------------------------------------
// Build registry/generators/[generator]/[name].json.
// ----------------------------------------------------------------------------
async function buildGenerators(registry: Registry) {
    for (const generator of generators) {
        const targetPath = path.join(REGISTRY_PATH, "generators", generator.name)

        // Create directory if it doesn't exist.
        if (!existsSync(targetPath)) {
            await fs.mkdir(targetPath, { recursive: true })
        }

        for (const item of registry.items) {
            if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
                continue
            }

            let files
            if (item.files) {
                files = await Promise.all(
                    item.files.map(async (_file) => {
                        const file =
                            typeof _file === "string"
                                ? {
                                    path: _file,
                                    type: item.type,
                                    content: "",
                                    target: "",
                                }
                                : _file

                        let content: string
                        try {

                            console.log(
                                "path.join(process.cwd(), 'registry', generator.name, file.path)",
                                path.join(process.cwd(), "registry", generator.name, file.path)
                            )

                            let sourcePath = path.join(process.cwd(), "registry", "generator", generator.name, file.path)

                            content = await fs.readFile(
                                sourcePath,
                                "utf8"
                            )

                            console.log("content", content)
                        } catch (error) {
                            console.error("[buildGenerators]::error", error)
                            return
                        }

                        const tempFile = await createTempSourceFile(file.path)
                        const sourceFile = project.createSourceFile(tempFile, content, {
                            scriptKind: ScriptKind.TSX,
                        })

                        sourceFile.getVariableDeclaration("iframeHeight")?.remove()
                        sourceFile.getVariableDeclaration("containerClassName")?.remove()
                        sourceFile.getVariableDeclaration("description")?.remove()

                        let target = file.target || ""

                        return {
                            path: file.path,
                            type: file.type,
                            content: sourceFile.getText(),
                            target,
                        }
                    })
                )
            }

            const payload = registryItemSchema.safeParse({
                $schema: "https://thinkthroo.com/schema/registry-item.json",
                author: "Ramu Narasinga (https://thinkthroo.com)",
                ...item,
                files,
            })

            if (payload.success) {
                await fs.writeFile(
                    path.join(targetPath, `${item.name}.json`),
                    JSON.stringify(payload.data, null, 2),
                    "utf8"
                )
            }
        }
    }

    // ----------------------------------------------------------------------------
    // Build registry/styles/index.json.
    // ----------------------------------------------------------------------------
    const generatorsJson = JSON.stringify(generators, null, 2)
    await fs.writeFile(
        path.join(REGISTRY_PATH, "generators/index.json"),
        generatorsJson,
        "utf8"
    )
}

// ----------------------------------------------------------------------------
// Build registry/styles/[name]/index.json.
// ----------------------------------------------------------------------------
async function buildGeneratorsIndex() {
    for (const generator of generators) {
        const targetPath = path.join(REGISTRY_PATH, "generators", generator.name)

        const payload: z.infer<typeof registryItemSchema> = {
            name: generator.name,
            type: "registry:generator",
            dependencies: [],
            registryDependencies: [],
            files: [],
        }

        await fs.writeFile(
            path.join(targetPath, "index.json"),
            JSON.stringify(payload, null, 2),
            "utf8"
        )
    }
}


try {
    console.log("ðŸ’½ Building registry...")
    const result = registrySchema.safeParse(registry)

    if (!result.success) {
        console.error(result.error)
        process.exit(1)
    }

    await buildRegistry(result.data)
    await buildGenerators(result.data)
    await buildGeneratorsIndex()

    console.log("âœ… Done!")
} catch (error) {
    console.error(error)
    process.exit(1)
}