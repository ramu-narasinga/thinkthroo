{
  "title": "ReactDOM.unstable_batchedUpdates in Zustand testcase.\r",
  "published": false,
  "featured": false,
  "component": false,
  "toc": true,
  "body": {
    "raw": "\r\nIn this article, we will look into the use of `ReactDOM.unstable_batchedUpdates` within a test case, specifically in Zustand, a popular state management library for React. We'll also break down the test and explain how batched updates enhance performance in React by minimizing unnecessary re-renders.\r\n\r\n# **Understanding the Test Case**\r\n\r\nHere is the test case we’ll be examining:\r\n\r\n![](https://miro.medium.com/v2/resize:fit:875/1*LLesFA1QatYEPErFCmQ_oA.png)\r\n\r\nThis test case is written to verify that batched updates can be applied when using Zustand with React’s rendering system.\r\n\r\n# **Breaking Down the Test Case**\r\n\r\n**1\\. Zustand Store Setup:** The first step involves creating a Zustand store using the `create` function:\r\n\r\n```plaintext\r\nconst useBoundStore = create<CounterState>(\r\n  (set) => ({   \r\n  count: 0,   \r\n  inc: () => set((state) => ({ count: state.count + 1 })), }))\r\n```\r\n\r\nHere, the store maintains a simple state with a `count` property initialized to 0 and an `inc` function to increment the count. The `set` function is Zustand’s way of updating the state, similar to `setState` in React.\r\n\r\n**2\\. Counter Component:** The `Counter` component uses the `useBoundStore` to retrieve the current `count` and the `inc` function:\r\n\r\n```plaintext\r\nconst { count, inc } = useBoundStore()\r\n```\r\n\r\nThis component subscribes to the store’s state, and any changes to `count` will cause it to re-render with the new value.\r\n\r\n**3\\. Using** `ReactDOM.unstable_batchedUpdates` **for Performance:** Inside the `useEffect` hook, the `inc` function is called twice within a `ReactDOM.unstable_batchedUpdates` block:\r\n\r\n```plaintext\r\nuseEffect(() => {   \r\n  ReactDOM.unstable_batchedUpdates(() => {     \r\n    inc()     \r\n    inc()   \r\n  }) \r\n}, [inc])\r\n```\r\n\r\nThis is where the magic happens. Normally, each call to `inc()` would trigger a separate update, causing two renders. However, by wrapping these calls in `unstable_batchedUpdates`, React is able to process them together in a single update, resulting in only one render. This optimizes performance by reducing the number of renders, which is especially useful in performance-critical applications.\r\n\r\n**4\\. Rendering the Component and Asserting the Result** Finally, the component is rendered, and the test waits for the `count` to reach 2:\r\n\r\n```plaintext\r\nconst { findByText } = render(\r\n  <>     \r\n    <Counter />   \r\n  </>, \r\n)  \r\n\r\nawait findByText('count: 2')\r\n```\r\n\r\nThis assertion ensures that after two increments, the `count` is correctly updated and rendered as \"count: 2\".\r\n\r\n# **What is** `ReactDOM.unstable_batchedUpdates`?\r\n\r\n`ReactDOM.unstable_batchedUpdates` is a method provided by React that allows multiple state updates to be processed in a single render cycle. By default, React batches updates triggered inside event handlers (for example, click event), meaning that if you update multiple states in response to a user interaction, React will render the component only once. However, outside of event handlers (like within `setTimeout` or `useEffect`), updates are not batched automatically.\r\n\r\nBut this has changed after React 18. Below are the screenshots picked from [react.dev](https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching)\r\n\r\n![](https://miro.medium.com/v2/resize:fit:875/1*lG7738BQKryZzAyAK3p6UQ.png)\r\n\r\n![](https://miro.medium.com/v2/resize:fit:875/1*yJylBoQho0Dqb3JXkFPfSA.png)\r\n\r\nKeep in mind, [documentation](https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching) suggests that updates inside of timeouts, promises, native event handlers or any other event will batch the same way as updates inside of React events. But in this [Zustand’s test case](https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L166), batch updates are applied inside ``useEffect`.``This is where `unstable_batchedUpdates` becomes useful. It forces React to group multiple state updates into a single render, even outside of event-driven contexts, minimizing re-renders and improving performance.\r\n\r\n**Example:**\r\n\r\nWithout `unstable_batchedUpdates`:\r\n\r\n```plaintext\r\ninc()  // triggers one render\r\ninc()  // triggers another render\r\n```\r\n\r\nWith `unstable_batchedUpdates`:\r\n\r\n```plaintext\r\nReactDOM.unstable_batchedUpdates(() => {\r\n  inc()  // triggers only one render for both updates\r\n  inc()\r\n})\r\n```\r\n\r\nThe method is labeled “unstable” because it’s not part of React’s official public API, but it is still widely used in the community for performance optimizations. It may become more stable or integrated as part of React’s new concurrent rendering capabilities in the future.\r\n\r\nFun fact: Zustand’s 4.5.5 release uses the version — 19.0.0-rc.0\r\n\r\n![](https://miro.medium.com/v2/resize:fit:875/1*DeB6dAYRCXAHkZNsYJbZtg.png)\r\n\r\n# **Why Use** `ReactDOM.unstable_batchedUpdates` in Zustand?\r\n\r\nZustand is a lightweight state management library that works with React’s component lifecycle. Although Zustand efficiently handles state updates, React’s reactivity system will trigger renders every time the state changes. In scenarios where multiple state changes occur in a short period, using `ReactDOM.unstable_batchedUpdates` can prevent multiple re-renders and batch the updates, allowing for a smoother, more efficient user experience.\r\n\r\nIn the test case provided, calling `inc` twice within a batched update ensures that the `count` only updates once, making it more efficient compared to running each update individually.\r\n\r\n# **About me:**\r\n\r\nHey, my name is Ramu Narasinga. I study large open-source projects and create content about their codebase architecture and best practices, sharing it through articles, videos.\r\n\r\nI am open to work on interesting projects. Send me an email at ramu.narasinga@gmail.com\r\n\r\nMy Github — [https://github.com/ramu-narasinga](https://github.com/ramu-narasinga)\r\n\r\nMy website — [https://ramunarasinga.com](https://ramunarasinga.com/)\r\n\r\nMy Youtube channel — [https://www.youtube.com/@thinkthroo](https://www.youtube.com/@thinkthroo)\r\n\r\nLearning platform — [https://thinkthroo.com](https://thinkthroo.com/)\r\n\r\nCodebase Architecture — [https://app.thinkthroo.com/architecture](https://app.thinkthroo.com/architecture)\r\n\r\nBest practices — [https://app.thinkthroo.com/best-practices](https://app.thinkthroo.com/best-practices)\r\n\r\nProduction-grade projects — [https://app.thinkthroo.com/production-grade-projects](https://app.thinkthroo.com/production-grade-projects)\r\n\r\n# **References:**\r\n\r\n1. [https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L175C7-L175C39](https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L175C7-L175C39)\r\n    \r\n2. [https://dev.to/devmoustafa97/do-you-know-unstablebatchedupdates-in-react-enforce-batching-state-update-5cn2](https://dev.to/devmoustafa97/do-you-know-unstablebatchedupdates-in-react-enforce-batching-state-update-5cn2)\r\n    \r\n3. [https://dev.to/jackbuchananconroy/react-18-what-s-changed-automatic-batching-13ec](https://dev.to/jackbuchananconroy/react-18-what-s-changed-automatic-batching-13ec)\r\n    \r\n4. [https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching](https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching)\r\n    \r\n5. [https://github.com/pmndrs/zustand/blob/v4.5.5/package.json#L246C4-L247C32](https://github.com/pmndrs/zustand/blob/v4.5.5/package.json#L246C4-L247C32)\r\n    \r\n\r\n[  \r\n](https://medium.com/tag/javascript?source=post_page-----165300ceea8c--------------------------------)\r\n",
    "code": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),y=(n,e)=>{for(var a in e)c(n,a,{get:e[a],enumerable:!0})},s=(n,e,a,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!b.call(n,i)&&i!==a&&c(n,i,{get:()=>e[i],enumerable:!(r=u(e,i))||r.enumerable});return n};var w=(n,e,a)=>(a=n!=null?p(g(n)):{},s(e||!n||!n.__esModule?c(a,\"default\",{value:n,enumerable:!0}):a,n)),v=n=>s(c({},\"__esModule\",{value:!0}),n);var h=f((N,d)=>{d.exports=_jsx_runtime});var k={};y(k,{default:()=>o,frontmatter:()=>x});var t=w(h()),x={title:\"ReactDOM.unstable_batchedUpdates in Zustand testcase.\"};function l(n){let e={a:\"a\",br:\"br\",code:\"code\",div:\"div\",h1:\"h1\",img:\"img\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",span:\"span\",strong:\"strong\",...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"In this article, we will look into the use of \",(0,t.jsx)(e.code,{children:\"ReactDOM.unstable_batchedUpdates\"}),\" within a test case, specifically in Zustand, a popular state management library for React. We'll also break down the test and explain how batched updates enhance performance in React by minimizing unnecessary re-renders.\"]}),`\n`,(0,t.jsx)(e.h1,{id:\"understanding-the-test-case\",children:(0,t.jsx)(e.strong,{children:\"Understanding the Test Case\"})}),`\n`,(0,t.jsx)(e.p,{children:\"Here is the test case we\\u2019ll be examining:\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"https://miro.medium.com/v2/resize:fit:875/1*LLesFA1QatYEPErFCmQ_oA.png\",alt:\"\"})}),`\n`,(0,t.jsx)(e.p,{children:\"This test case is written to verify that batched updates can be applied when using Zustand with React\\u2019s rendering system.\"}),`\n`,(0,t.jsx)(e.h1,{id:\"breaking-down-the-test-case\",children:(0,t.jsx)(e.strong,{children:\"Breaking Down the Test Case\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"1. Zustand Store Setup:\"}),\" The first step involves creating a Zustand store using the \",(0,t.jsx)(e.code,{children:\"create\"}),\" function:\"]}),`\n`,(0,t.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,t.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,t.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"const useBoundStore = create<CounterState>(\"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"  (set) => ({   \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"  count: 0,   \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"  inc: () => set((state) => ({ count: state.count + 1 })), }))\"})})]})})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Here, the store maintains a simple state with a \",(0,t.jsx)(e.code,{children:\"count\"}),\" property initialized to 0 and an \",(0,t.jsx)(e.code,{children:\"inc\"}),\" function to increment the count. The \",(0,t.jsx)(e.code,{children:\"set\"}),\" function is Zustand\\u2019s way of updating the state, similar to \",(0,t.jsx)(e.code,{children:\"setState\"}),\" in React.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"2. Counter Component:\"}),\" The \",(0,t.jsx)(e.code,{children:\"Counter\"}),\" component uses the \",(0,t.jsx)(e.code,{children:\"useBoundStore\"}),\" to retrieve the current \",(0,t.jsx)(e.code,{children:\"count\"}),\" and the \",(0,t.jsx)(e.code,{children:\"inc\"}),\" function:\"]}),`\n`,(0,t.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,t.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,t.jsx)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"const { count, inc } = useBoundStore()\"})})})})}),`\n`,(0,t.jsxs)(e.p,{children:[\"This component subscribes to the store\\u2019s state, and any changes to \",(0,t.jsx)(e.code,{children:\"count\"}),\" will cause it to re-render with the new value.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"3. Using\"}),\" \",(0,t.jsx)(e.code,{children:\"ReactDOM.unstable_batchedUpdates\"}),\" \",(0,t.jsx)(e.strong,{children:\"for Performance:\"}),\" Inside the \",(0,t.jsx)(e.code,{children:\"useEffect\"}),\" hook, the \",(0,t.jsx)(e.code,{children:\"inc\"}),\" function is called twice within a \",(0,t.jsx)(e.code,{children:\"ReactDOM.unstable_batchedUpdates\"}),\" block:\"]}),`\n`,(0,t.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,t.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,t.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"useEffect(() => {   \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"  ReactDOM.unstable_batchedUpdates(() => {     \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"    inc()     \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"    inc()   \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"  }) \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"}, [inc])\"})})]})})}),`\n`,(0,t.jsxs)(e.p,{children:[\"This is where the magic happens. Normally, each call to \",(0,t.jsx)(e.code,{children:\"inc()\"}),\" would trigger a separate update, causing two renders. However, by wrapping these calls in \",(0,t.jsx)(e.code,{children:\"unstable_batchedUpdates\"}),\", React is able to process them together in a single update, resulting in only one render. This optimizes performance by reducing the number of renders, which is especially useful in performance-critical applications.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"4. Rendering the Component and Asserting the Result\"}),\" Finally, the component is rendered, and the test waits for the \",(0,t.jsx)(e.code,{children:\"count\"}),\" to reach 2:\"]}),`\n`,(0,t.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,t.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,t.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"const { findByText } = render(\"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"  <>     \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"    <Counter />   \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"  </>, \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\")  \"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"await findByText('count: 2')\"})})]})})}),`\n`,(0,t.jsxs)(e.p,{children:[\"This assertion ensures that after two increments, the \",(0,t.jsx)(e.code,{children:\"count\"}),' is correctly updated and rendered as \"count: 2\".']}),`\n`,(0,t.jsxs)(e.h1,{id:\"what-is-reactdomunstable_batchedupdates\",children:[(0,t.jsx)(e.strong,{children:\"What is\"}),\" \",(0,t.jsx)(e.code,{children:\"ReactDOM.unstable_batchedUpdates\"}),\"?\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"ReactDOM.unstable_batchedUpdates\"}),\" is a method provided by React that allows multiple state updates to be processed in a single render cycle. By default, React batches updates triggered inside event handlers (for example, click event), meaning that if you update multiple states in response to a user interaction, React will render the component only once. However, outside of event handlers (like within \",(0,t.jsx)(e.code,{children:\"setTimeout\"}),\" or \",(0,t.jsx)(e.code,{children:\"useEffect\"}),\"), updates are not batched automatically.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"But this has changed after React 18. Below are the screenshots picked from \",(0,t.jsx)(e.a,{href:\"https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching\",children:\"react.dev\"})]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"https://miro.medium.com/v2/resize:fit:875/1*lG7738BQKryZzAyAK3p6UQ.png\",alt:\"\"})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"https://miro.medium.com/v2/resize:fit:875/1*yJylBoQho0Dqb3JXkFPfSA.png\",alt:\"\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Keep in mind, \",(0,t.jsx)(e.a,{href:\"https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching\",children:\"documentation\"}),\" suggests that updates inside of timeouts, promises, native event handlers or any other event will batch the same way as updates inside of React events. But in this \",(0,t.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L166\",children:\"Zustand\\u2019s test case\"}),\", batch updates are applied inside \",(0,t.jsx)(e.code,{children:\"useEffect`.\"}),\"This is where \",(0,t.jsx)(e.code,{children:\"unstable_batchedUpdates\"}),\" becomes useful. It forces React to group multiple state updates into a single render, even outside of event-driven contexts, minimizing re-renders and improving performance.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:\"Example:\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Without \",(0,t.jsx)(e.code,{children:\"unstable_batchedUpdates\"}),\":\"]}),`\n`,(0,t.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,t.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,t.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"inc()  // triggers one render\"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"inc()  // triggers another render\"})})]})})}),`\n`,(0,t.jsxs)(e.p,{children:[\"With \",(0,t.jsx)(e.code,{children:\"unstable_batchedUpdates\"}),\":\"]}),`\n`,(0,t.jsx)(e.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,t.jsx)(e.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,t.jsxs)(e.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"ReactDOM.unstable_batchedUpdates(() => {\"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"  inc()  // triggers only one render for both updates\"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"  inc()\"})}),`\n`,(0,t.jsx)(e.span,{className:\"line\",children:(0,t.jsx)(e.span,{children:\"})\"})})]})})}),`\n`,(0,t.jsx)(e.p,{children:\"The method is labeled \\u201Cunstable\\u201D because it\\u2019s not part of React\\u2019s official public API, but it is still widely used in the community for performance optimizations. It may become more stable or integrated as part of React\\u2019s new concurrent rendering capabilities in the future.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Fun fact: Zustand\\u2019s 4.5.5 release uses the version \\u2014 19.0.0-rc.0\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"https://miro.medium.com/v2/resize:fit:875/1*DeB6dAYRCXAHkZNsYJbZtg.png\",alt:\"\"})}),`\n`,(0,t.jsxs)(e.h1,{id:\"why-use-reactdomunstable_batchedupdates-in-zustand\",children:[(0,t.jsx)(e.strong,{children:\"Why Use\"}),\" \",(0,t.jsx)(e.code,{children:\"ReactDOM.unstable_batchedUpdates\"}),\" in Zustand?\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Zustand is a lightweight state management library that works with React\\u2019s component lifecycle. Although Zustand efficiently handles state updates, React\\u2019s reactivity system will trigger renders every time the state changes. In scenarios where multiple state changes occur in a short period, using \",(0,t.jsx)(e.code,{children:\"ReactDOM.unstable_batchedUpdates\"}),\" can prevent multiple re-renders and batch the updates, allowing for a smoother, more efficient user experience.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the test case provided, calling \",(0,t.jsx)(e.code,{children:\"inc\"}),\" twice within a batched update ensures that the \",(0,t.jsx)(e.code,{children:\"count\"}),\" only updates once, making it more efficient compared to running each update individually.\"]}),`\n`,(0,t.jsx)(e.h1,{id:\"about-me\",children:(0,t.jsx)(e.strong,{children:\"About me:\"})}),`\n`,(0,t.jsx)(e.p,{children:\"Hey, my name is Ramu Narasinga. I study large open-source projects and create content about their codebase architecture and best practices, sharing it through articles, videos.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"I am open to work on interesting projects. Send me an email at \",(0,t.jsx)(e.a,{href:\"mailto:ramu.narasinga@gmail.com\",children:\"ramu.narasinga@gmail.com\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"My Github \\u2014 \",(0,t.jsx)(e.a,{href:\"https://github.com/ramu-narasinga\",children:\"https://github.com/ramu-narasinga\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"My website \\u2014 \",(0,t.jsx)(e.a,{href:\"https://ramunarasinga.com/\",children:\"https://ramunarasinga.com\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"My Youtube channel \\u2014 \",(0,t.jsx)(e.a,{href:\"https://www.youtube.com/@thinkthroo\",children:\"https://www.youtube.com/@thinkthroo\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Learning platform \\u2014 \",(0,t.jsx)(e.a,{href:\"https://thinkthroo.com/\",children:\"https://thinkthroo.com\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Codebase Architecture \\u2014 \",(0,t.jsx)(e.a,{href:\"https://app.thinkthroo.com/architecture\",children:\"https://app.thinkthroo.com/architecture\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Best practices \\u2014 \",(0,t.jsx)(e.a,{href:\"https://app.thinkthroo.com/best-practices\",children:\"https://app.thinkthroo.com/best-practices\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Production-grade projects \\u2014 \",(0,t.jsx)(e.a,{href:\"https://app.thinkthroo.com/production-grade-projects\",children:\"https://app.thinkthroo.com/production-grade-projects\"})]}),`\n`,(0,t.jsx)(e.h1,{id:\"references\",children:(0,t.jsx)(e.strong,{children:\"References:\"})}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L175C7-L175C39\",children:\"https://github.com/pmndrs/zustand/blob/v4.5.5/tests/basic.test.tsx#L175C7-L175C39\"})}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:\"https://dev.to/devmoustafa97/do-you-know-unstablebatchedupdates-in-react-enforce-batching-state-update-5cn2\",children:\"https://dev.to/devmoustafa97/do-you-know-unstablebatchedupdates-in-react-enforce-batching-state-update-5cn2\"})}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:\"https://dev.to/jackbuchananconroy/react-18-what-s-changed-automatic-batching-13ec\",children:\"https://dev.to/jackbuchananconroy/react-18-what-s-changed-automatic-batching-13ec\"})}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:\"https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching\",children:\"https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching\"})}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:\"https://github.com/pmndrs/zustand/blob/v4.5.5/package.json#L246C4-L247C32\",children:\"https://github.com/pmndrs/zustand/blob/v4.5.5/package.json#L246C4-L247C32\"})}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsxs)(e.a,{href:\"https://medium.com/tag/javascript?source=post_page-----165300ceea8c--------------------------------\",children:[(0,t.jsx)(e.br,{}),`\n`]})})]})}function o(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(l,{...n})}):l(n)}return v(k);})();\n;return Component;"
  },
  "_id": "blog/ReactDOMunstablebatchedUpdates-in-zustand.mdx",
  "_raw": {
    "sourceFilePath": "blog/ReactDOMunstablebatchedUpdates-in-zustand.mdx",
    "sourceFileName": "ReactDOMunstablebatchedUpdates-in-zustand.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/ReactDOMunstablebatchedUpdates-in-zustand"
  },
  "type": "Doc",
  "slug": "/blog/ReactDOMunstablebatchedUpdates-in-zustand",
  "slugAsParams": "ReactDOMunstablebatchedUpdates-in-zustand"
}