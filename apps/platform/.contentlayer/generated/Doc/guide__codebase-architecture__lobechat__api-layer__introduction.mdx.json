{
  "title": "API Layer in LobeChat\r",
  "published": false,
  "featured": false,
  "component": false,
  "toc": true,
  "body": {
    "raw": "\r\nIn this guide, you will learn the API layer used in [Lobe Chat](https://github.com/lobehub/lobe-chat/tree/main). \r\n\r\nü§Ø Lobe Chat is an open-source, modern-design AI chat framework. Supports \r\n  Multi AI Providers( OpenAI / Claude 3 / Gemini / Ollama / Azure / DeepSeek), \r\nKnowledge Base (file upload / knowledge management / RAG ), Multi-Modals (Vision/TTS) and plugin system. \r\n  One-click FREE deployment of your private ChatGPT/ Claude application. \r\n\r\n# What's API Layer?\r\nIn the context of web applications, API layer means communicating with your server to get/mutate data.\r\nInspired by [Bulletproof React's API Layer](https://github.com/alan2207/bulletproof-react/blob/master/docs/api-layer.md)\r\nWe analyze the API Layer in the [Lobechat](https://github.com/lobehub/lobe-chat/tree/main). \r\n\r\n# Lobe Chat API Layer\r\nTo study the API Layer, we pick a page on https://chat-preview.lobehub.com/ and look at the source code except we are\r\nnarrowing down our expedition to focus on the API Layer.\r\n\r\n# Concepts you will learn:\r\nYou will be learning the API layer used in the Lobe Chat. \r\nRead through this guide to understand how Lobe Chat's API layer works.\r\n\r\n## Data fetched in Discover Home Page\r\n1. [Discover Home Page]\r\n(https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/page.tsx)\r\n2. [DiscoverService](https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L27)\r\n\r\nIn this guide, we will find out how the API layer is implemented in Discover page. You will learn how the data is fetched\r\nin the Discover page.\r\n\r\n[Insert a screenshot of Discover page - https://lobechat.com/discover]\r\n\r\nDiscover page has Home, Assistants, Plugins etc., tabs. For this guide, let's pick assistants tab and \r\nfind out how the data is fetched.\r\n\r\nIn the [Discover page.tsx](https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/page.tsx),\r\nYou will find the below code snippet.\r\n\r\n```\r\nconst discoverService = new DiscoverService();\r\nconst assistantList = await discoverService.getAssistantList(locale);\r\nconst pluginList = await discoverService.getPluginList(locale);\r\nconst modelList = await discoverService.getModelList(locale);\r\n```\r\n### DiscoverService\r\n\r\n[DiscoverService](https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L52) is class that is\r\ninstantiated using `new DiscoverService()`. You could also just export the functions from a service file but using a class\r\nin a service helps you organize your functions better as your functions are encapsulated in a class. This approach also make it\r\neasy to mock your service for testing purposes. \r\n\r\n### discoverService.getAssistantList(locale)\r\n\r\n```\r\ngetAssistantList = async (locale: Locales): Promise<DiscoverAssistantItem[]> => {\r\n    let res = await fetch(this.assistantStore.getAgentIndexUrl(locale), {\r\n      next: { revalidate },\r\n    });\r\n\r\n    if (!res.ok) {\r\n      res = await fetch(this.assistantStore.getAgentIndexUrl(DEFAULT_LANG), {\r\n        next: { revalidate },\r\n      });\r\n    }\r\n\r\n    if (!res.ok) return [];\r\n\r\n    const json = await res.json();\r\n\r\n    return json.agents;\r\n};\r\n```\r\nThis above code snippet is picked from [getAssistantList](https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L52)\r\n\r\nThis function uses [fetch](https://nextjs.org/docs/app/api-reference/functions/fetch). Next.js extends the native Web \r\nfetch() API to allow each request on the server to set its own persistent caching semantics.\r\n\r\nLet's understand what this second param in the above fetch does.\r\n```\r\n{\r\n  next: { revalidate },\r\n}\r\n```\r\n[options.next.revalidate](https://nextjs.org/docs/app/api-reference/functions/fetch#optionsnextrevalidate) from the \r\nNext.js documentation.\r\n\r\nSet the cache lifetime of a resource (in seconds).\r\n1. false - Cache the resource indefinitely. Semantically equivalent to revalidate: Infinity. The HTTP cache may evict older resources over time.\r\n2. 0 - Prevent the resource from being cached.\r\n3. number - (in seconds) Specify the resource should have a cache lifetime of at most n seconds.\r\n\r\nso where's revalidate value coming from in [Discover service](https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L25)?\r\nrevalidate is initialized at L25:\r\n\r\n```\r\nconst revalidate: number = 3600;\r\n```\r\nThis 3600 is in seconds which is 1 hour. getAssistantList has a cache lifetime of at most 1 hour.\r\n\r\n`assistantStore.getAgentIndexUrl` returns the URL used in the fetch API.\r\n\r\n[Insert a screenshot of https://github.com/lobehub/lobe-chat/blob/main/src/server/modules/AssistantStore/index.ts#L14]\r\n\r\n## References:\r\n1. https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/page.tsx\r\n2. https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/Client.tsx\r\n3. https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/features/AssistantList.tsx\r\n4. https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L28\r\n5. https://github.com/lobehub/lobe-chat/blob/main/src/server/modules/AssistantStore/index.ts\r\n\r\n## Data fetched in Chat Page\r\n\r\nData fetched in the Chat page is different to what you have seen in getAssistantList in discover service. \r\ngetAssistantList uses fetch, where as Chat uses `useSWR`. Let's find out how this is done.\r\n\r\n[insert screenshot of lobechat chat session page]\r\n\r\nYou will find useFetchSessions hook in [SessionListContent/DefaultMode.tsx](https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/chat/%40session/features/SessionListContent/DefaultMode.tsx#L29)\r\nuseFetchSession is in useSessionStore. API layer is tightly coupled with state management in Lobechat. We want to focus\r\nonly on API layer, check out the [state management in lobechat](link to lobechat state management).\r\n\r\n[Insert screenshot of https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/chat/%40session/features/SessionListContent/DefaultMode.tsx#L29]\r\n\r\n## useFetchSessions in session store:\r\nYou will find the below code for the useFetchSessions in [session/action.ts](https://github.com/lobehub/lobe-chat/blob/main/src/store/session/slices/session/action.ts#L200)\r\n\r\n```\r\nuseFetchSessions: (isLogin) =>\r\n    useClientDataSWR<ChatSessionList>(\r\n      [FETCH_SESSIONS_KEY, isLogin],\r\n      () => sessionService.getGroupedSessions(),\r\n      {\r\n        fallbackData: {\r\n          sessionGroups: [],\r\n          sessions: [],\r\n        },\r\n        onSuccess: (data) => {\r\n          if (\r\n            get().isSessionsFirstFetchFinished &&\r\n            isEqual(get().sessions, data.sessions) &&\r\n            isEqual(get().sessionGroups, data.sessionGroups)\r\n          )\r\n            return;\r\n\r\n          get().internal_processSessions(\r\n            data.sessions,\r\n            data.sessionGroups,\r\n            n('useFetchSessions/updateData') as any,\r\n          );\r\n          set({ isSessionsFirstFetchFinished: true }, false, n('useFetchSessions/onSuccess', data));\r\n        },\r\n        suspense: true,\r\n      },\r\n    ),\r\n```\r\n\r\nLooks compicated, let's break it down. It uses:\r\n\r\n1. useClientDataSWR\r\n\r\nuseClientDataSWR is imported from [libs/swr/index.ts](https://github.com/lobehub/lobe-chat/blob/main/src/libs/swr/index.ts#L22C14-L22C30)\r\n\r\n```\r\nexport const useClientDataSWR: SWRHook = (key, fetch, config) =>\r\n  useSWR(key, fetch, {\r\n    // default is 2000ms ,it makes the user's quick switch don't work correctly.\r\n    // Cause issue like this: https://github.com/lobehub/lobe-chat/issues/532\r\n    // we need to set it to 0.\r\n    dedupingInterval: 0,\r\n    focusThrottleInterval: 5 * 60 * 1000,\r\n    refreshWhenOffline: false,\r\n    revalidateOnFocus: true,\r\n    revalidateOnReconnect: true,\r\n    ...config,\r\n  });\r\n```\r\n\r\nuseSWR is a React hook for data fetching provided by [Vercel's SWR API](https://swr.vercel.app/).\r\nThe name ‚ÄúSWR‚Äù is derived from stale-while-revalidate, a HTTP cache invalidation strategy popularized by \r\nHTTP RFC 5861(opens in a new tab). SWR is a strategy to first return the data from cache (stale), then send \r\nthe fetch request (revalidate), and finally come with the up-to-date data.   \r\n\r\nLet's now understand what each of these options do by referring to the documentation:\r\na. dedupingInterval\r\n\r\n[SWR Docs](https://swr.vercel.app/docs/api#parameters) mentions this - dedupingInterval = 2000: dedupe requests with the same key in this time span in milliseconds \r\n\r\nbut Lobechat has this configured to 0 and it explains why with a nice comment.\r\n\r\n```\r\n// default is 2000ms ,it makes the user's quick switch don't work correctly.\r\n// Cause issue like this: https://github.com/lobehub/lobe-chat/issues/532\r\n// we need to set it to 0.\r\ndedupingInterval: 0,\r\n```\r\njust in case, if you were wondering what dedupe means, it is about removing duplicates.\r\n\r\nb. focusThrottleInterval:\r\n\r\n[SWR docs](https://swr.vercel.app/docs/api#parameters) provides this information about focusThrottleInterval - \r\nfocusThrottleInterval = 5000: only revalidate once during a time span in milliseconds\r\n\r\nIn the context of useSWR, the focusThrottleInterval option controls how frequently the data revalidation \r\nhappens when the window or tab regains focus.\r\n\r\n### ChatGPT's explanation:\r\n\r\nExplanation in the useSWR context:\r\nSWR's behavior with focus: By default, SWR will revalidate (i.e., refetch) the data whenever the user \r\nswitches back to the app or tab (when the window or tab regains focus). This is useful because it ensures that \r\nthe data displayed is up-to-date when the user returns to the app.\r\n\r\nfocusThrottleInterval = 5000: This option tells SWR to throttle the revalidation when focus changes. \r\nSpecifically, it will revalidate data at most once every 5000 milliseconds (or 5 seconds).\r\n\r\nIf a user quickly switches between tabs or focuses on the app multiple times in rapid succession, \r\nSWR will ensure that revalidation only happens once within that 5-second window, preventing excessive \r\nor redundant requests.\r\n\r\nWhat's the value that lobechat uses?\r\n```\r\nfocusThrottleInterval: 5 * 60 * 1000\r\n```\r\nConverting 5 * 60 * 1000 milliseconds, it is 5 minutes. What this means is that when you focus by revisiting lobechat\r\napplication, data is not refreshed until 5 minutes but by then you would visit different pages, differen chats \r\nand latest data might load already but that depends on the actions that you perform.\r\n\r\nc. refreshWhenOffline:\r\n\r\n### SWR documentation explanation:\r\nrefreshWhenOffline = false: polling when the browser is offline \r\n(determined by navigator.onLine), Read more about [refreshWhenOffline](https://swr.vercel.app/docs/api#parameters)\r\n\r\n### ChatGPT explanation:\r\nSWR offers an option to periodically refetch data in the background (polling), but when the browser \r\ngoes offline, trying to fetch data may be pointless. To prevent unnecessary requests, setting \r\n`refreshWhenOffline = false` ensures polling is paused when the browser is offline, \r\nsaving resources and avoiding failed fetch attempts.\r\n\r\n### What's the value that lobechat uses?\r\n\r\n```\r\nrefreshWhenOffline: false\r\n```\r\n\r\nd. revalidateOnFocus:\r\n\r\n### SWR documentation explanation:\r\nrevalidateOnFocus = true: automatically revalidate when window gets focused ([details](https://swr.vercel.app/docs/revalidation))\r\n\r\n### ChatGPT explanation:\r\n- Revalidate: In SWR, \"revalidate\" refers to refetching data from the source (e.g., an API) \r\nto ensure the data is still up-to-date.\r\n- Focus events: In web applications, a \"focus\" event occurs when the user returns to the browser window or tab, \r\neither after switching tabs, windows, or after minimizing and reopening the app.\r\n- revalidateOnFocus = true: This setting enables the app to automatically revalidate (refetch data) every time\r\nthe user switches back to the tab. By default, this is set to true in SWR, meaning the data will be refreshed every time the tab regains focus.\r\n\r\n### What's the value that lobechat uses?\r\n\r\n```\r\nrevalidateOnFocus: true,\r\n```\r\n\r\nd. revalidateOnReconnect:\r\n\r\n### SWR documentation explanation:\r\nrevalidateOnReconnect = true: automatically revalidate when the browser regains a network connection (via navigator.onLine) ([details](https://swr.vercel.app/docs/revalidation))\r\n\r\n### ChatGPT explanation:\r\n\r\n- Revalidate: In SWR, revalidation refers to refetching data from the server to ensure it's up-to-date.\r\n- Reconnect: This event happens when the browser loses and then regains internet connectivity. The browser \r\ndetects this change using the navigator.onLine property:\r\ntrue: Browser is online (connected to the internet).\r\nfalse: Browser is offline (disconnected from the internet).\r\n- revalidateOnReconnect = true: This setting ensures that whenever the browser switches from an offline state back to an \r\nonline state, SWR will automatically refetch the data.\r\n\r\n### What's the value that lobechat uses?\r\n\r\n```\r\nrevalidateOnReconnect: true\r\n```\r\n\r\n## Params:\r\nNow that we understand useClientDataSWR and its options, let's look at the params used. The first param is the key\r\n\r\n```\r\nuseClientDataSWR<ChatSessionList>(\r\n      [FETCH_SESSIONS_KEY, isLogin],\r\n```\r\n\r\nThe second param is the fetch function written in [sessionService.getGroupedSessions()](https://github.com/lobehub/lobe-chat/blob/main/src/services/session/server.ts#L49)\r\n\r\nThird params is the additional config passed to useClientDataSWR function.\r\n\r\nAt this point, we are introduced to the new unknown `sessionService`. Let's analyze sessionService.\r\n\r\n\r\n# References:\r\n1. [Session List](https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/chat/%40session/features/SessionListContent/DefaultMode.tsx#L29)\r\n2. [useFetchSessions](https://github.com/lobehub/lobe-chat/blob/main/src/store/session/slices/session/action.ts#L200)\r\n3. [useClientDataSWR](https://github.com/lobehub/lobe-chat/blob/main/src/libs/swr/index.ts#L22C14-L22C30)\r\n\r\n[C: sessionService]\r\n\r\nIn this guide, we analyze the [sessionService](https://github.com/lobehub/lobe-chat/blob/main/src/services/session/server.ts#L49),\r\nthat gets called in a store. \r\n\r\nThe way we approach this is that we pick a function, understand it and see where it leads us.\r\n\r\n# getGroupedSessions()\r\n\r\n[getGroupedSessions()](https://github.com/lobehub/lobe-chat/blob/main/src/services/session/server.ts#L49) has the below\r\ncode:\r\n\r\n```\r\ngetGroupedSessions(): Promise<ChatSessionList> {\r\n  return lambdaClient.session.getGroupedSessions.query();\r\n}\r\n```\r\n\r\nThe unknown here is lambdaClient. What could this be about? to find that out, you have to see where \r\nlambdaClient is imported from.\r\n\r\n```\r\nimport { lambdaClient } from '@/libs/trpc/client';\r\n```\r\n\r\nlambdaClient is imported from `@libs/trpc/client`. This tells us that Lobechat uses tRPC. What's TRPC?\r\n\r\n# tRPC\r\nMove fast and break nothing. tRPC provides end-to-end typesafe APIs for your fullstack application.\r\n\r\nSince Lobechat uses app router, you may want to read this [set up with React components guide](https://trpc.io/docs/client/react/server-components)\r\nto understand how the tRPC is configured in Lobechat codebase.\r\n\r\nWe refer to the steps provided in [tRPC Setup with React Components](https://trpc.io/docs/client/react/server-components) \r\nand find out how Lobechat configured tRPC.\r\n\r\nUseful links:\r\n1. [tRPC](https://trpc.io/)\r\n2. [tRPC quick start](https://trpc.io/docs/quickstart)\r\n3. [Next.js, pages router + tRPC setup](https://trpc.io/docs/client/nextjs/setup)\r\n4. [Next.js, app router + tRPC setup](https://trpc.io/docs/client/react/server-components)\r\n\r\n## Dependencies required\r\n\r\n[tRPC docs](https://trpc.io/docs/client/react/server-components#1-install-deps) tells us to install the \r\nfollowing dependencies in your project:\r\n\r\n- @trpc/server@next\r\n- @trpc/client@next\r\n- @trpc/react-query@next\r\n- @tanstack/react-query@latest\r\n- zod\r\n- client-only\r\n- server-only\r\n\r\nLobechat has the following packages installed, available in [package.json](https://github.com/lobehub/lobe-chat/blob/main/package.json)\r\n\r\n```\r\n\"@tanstack/react-query\": \"^5.59.15\",\r\n\"@trpc/client\": \"next\",\r\n\"@trpc/next\": \"next\",\r\n\"@trpc/react-query\": \"next\",\r\n\"@trpc/server\": \"next\",\r\n\"zod\": \"^3.23.8\",\r\n```\r\n\r\nThere is no 'client-only', 'server-only' packages in Lobechat package.json and has a package named `@trpc/next` installed.\r\n\r\n## Create a tRPC router\r\n\r\n### tRPC Documentation summary\r\nYou would need create a tRPC router as explained in [tRPC docs](https://trpc.io/docs/client/react/server-components#2-create-a-trpc-router)\r\n\r\nYou create the following files:\r\n\r\n- trpc/init.ts\r\n- trpc/routers/_app.ts\r\n- app/api/trpc/[trpc]/route.ts\r\n\r\n### Lobechat implementation:\r\n\r\n#### init.ts \r\nYou will find init.ts in [src/libs/trpc/init.ts](https://github.com/lobehub/lobe-chat/blob/main/src/libs/trpc/init.ts)\r\n```\r\nexport const trpc = initTRPC.context<Context>().create({\r\n  /**\r\n   * @link https://trpc.io/docs/v11/error-formatting\r\n   */\r\n  errorFormatter({ shape }) {\r\n    return shape;\r\n  },\r\n  /**\r\n   * @link https://trpc.io/docs/v11/data-transformers\r\n   */\r\n  transformer: superjson,\r\n});\r\n```\r\n\r\nOnly tRPC is exported, but if you were to look at init.ts provided in documentation, it has the below code:\r\n\r\n```\r\nconst t = initTRPC.create({\r\n  /**\r\n   * @see https://trpc.io/docs/server/data-transformers\r\n   */\r\n  // transformer: superjson,\r\n});\r\n// Base router and procedure helpers\r\nexport const createTRPCRouter = t.router;\r\nexport const baseProcedure = t.procedure;\r\n```\r\n\r\nExamples provided in documentation exports router and procedure but Lobechat only exports `trpc` which is `t` in tRPC\r\ndocumentation example.\r\n\r\n#### routers\r\nIn the tRPC documentation, routers are defined in `trpc/routers/_app.ts`.\r\n\r\n```\r\nimport { z } from 'zod';\r\nimport { baseProcedure, createTRPCRouter } from '../init';\r\nexport const appRouter = createTRPCRouter({\r\n  hello: baseProcedure\r\n    .input(\r\n      z.object({\r\n        text: z.string(),\r\n      }),\r\n    )\r\n    .query((opts) => {\r\n      return {\r\n        greeting: `hello ${opts.input.text}`,\r\n      };\r\n    }),\r\n});\r\n// export type definition of API\r\nexport type AppRouter = typeof appRouter;\r\n```\r\n\r\nLobechat has a folder named routers in [server folder](https://github.com/lobehub/lobe-chat/tree/main/src/server/routers),\r\nWe chose [lambda/session.ts](https://github.com/lobehub/lobe-chat/blob/main/src/server/routers/lambda/session.ts) inside \r\nserver folder for explanation in this guide.\r\n\r\nFor you to register a route, you need trpc.router. This is imported from `@/lib/trpc`.\r\n\r\n```\r\nimport { authedProcedure, publicProcedure, router } from '@/libs/trpc';\r\n```\r\n\r\nFor example, [getSessions](https://github.com/lobehub/lobe-chat/blob/main/src/server/routers/lambda/session.ts#L92) \r\nis registered with the router as shown below:\r\n\r\n```\r\ngetSessions: sessionProcedure\r\n    .input(\r\n      z.object({\r\n        current: z.number().optional(),\r\n        pageSize: z.number().optional(),\r\n      }),\r\n    )\r\n    .query(async ({ input, ctx }) => {\r\n      const { current, pageSize } = input;\r\n\r\n      return ctx.sessionModel.query({ current, pageSize });\r\n    }),\r\n```\r\n\r\nwe have now been introduced to sessionModel that makes the database calls, we will learn more about sessionModel in the \r\nnext article.\r\n\r\n[sessionProcedure](https://github.com/lobehub/lobe-chat/blob/main/src/server/routers/lambda/session.ts#L13) is defined \r\nafter the imports in lambda/session.ts as shown below:\r\n\r\n```\r\nconst sessionProcedure = authedProcedure.use(async (opts) => {\r\n  const { ctx } = opts;\r\n\r\n  return opts.next({\r\n    ctx: {\r\n      sessionGroupModel: new SessionGroupModel(ctx.userId),\r\n      sessionModel: new SessionModel(ctx.userId),\r\n    },\r\n  });\r\n});\r\n```\r\n\r\nauthedProcedure is from `@libs/trpc`.\r\n\r\n```\r\n// procedure that asserts that the user is logged in\r\nexport const authedProcedure = trpc.procedure.use(userAuth);\r\n```\r\n\r\n[C: SessionModel]\r\n\r\nBased on the example, getSessions, we picked in the previous article, `sessionModel.query` is used. `query` function in\r\nsessionModel has the below code:\r\n\r\n```\r\nasync query({ current = 0, pageSize = 9999 } = {}) {\r\n    const offset = current * pageSize;\r\n\r\n    return serverDB.query.sessions.findMany({\r\n      limit: pageSize,\r\n      offset,\r\n      orderBy: [desc(sessions.updatedAt)],\r\n      where: and(eq(sessions.userId, this.userId), not(eq(sessions.slug, INBOX_SESSION_ID))),\r\n      with: { agentsToSessions: { columns: {}, with: { agent: true } }, group: true },\r\n    });\r\n}\r\n```\r\n\r\nUnknown here is serverDB. serverDB is imported from [database/server/core/db](https://github.com/lobehub/lobe-chat/blob/main/src/database/server/core/db.ts);\r\n\r\n```\r\nimport { serverDB } from '@/database/server/core/db';\r\n```\r\n\r\nIn Lobechat's tRPC procedures, models are used as an abstraction instead of directly dealing with database calls. \r\n\r\n[C: Database Core API]\r\n\r\nIn the previous chapter, we learnt that model uses serverDB imported from `@/database/server/core/db`. In this chapter, we \r\nanalyze the Lobechat's database core API.\r\n\r\nThe below imports are picked from [database/server/core/db.ts](https://github.com/lobehub/lobe-chat/blob/main/src/database/server/core/db.ts)\r\n\r\n```\r\nimport { Pool as NeonPool, neonConfig } from '@neondatabase/serverless';\r\nimport { NeonDatabase, drizzle as neonDrizzle } from 'drizzle-orm/neon-serverless';\r\nimport { drizzle as nodeDrizzle } from 'drizzle-orm/node-postgres';\r\nimport { Pool as NodePool } from 'pg';\r\nimport ws from 'ws';\r\n\r\nimport { serverDBEnv } from '@/config/db';\r\nimport { isServerMode } from '@/const/version';\r\n\r\nimport * as schema from '../schemas/lobechat';\r\n```\r\n\r\nYou can tell from the imports that Lobechat uses [Drizzle ORM](https://orm.drizzle.team/) and [Neon database](https://neon.tech/).\r\nCheck out this [Drizzle with Neon tutorial](https://orm.drizzle.team/docs/tutorials/drizzle-with-neon) to find out more.\r\nThis tutorial shows how to connect to Neon database using Drizzle.\r\n\r\n```\r\nimport { drizzle } from \"drizzle-orm/neon-http\";\r\nimport { neon } from \"@neondatabase/serverless\";\r\nimport { config } from \"dotenv\";\r\nconfig({ path: \".env\" }); // or .env.local\r\nconst sql = neon(process.env.DATABASE_URL!);\r\nexport const db = drizzle({ client: sql });\r\n```\r\n\r\nLobechat has additional checks as to which drizzle ORM is used. For example, in the below code:\r\n\r\n```\r\nif (serverDBEnv.DATABASE_DRIVER === 'node') {\r\n    const client = new NodePool({ connectionString });\r\n    return nodeDrizzle(client, { schema });\r\n}\r\n```\r\n\r\nnodeDrizzle here is imported from `drizzle-orm/node-postgres`.\r\n\r\nserverDBenv is imported from config/db.ts\r\n\r\n```\r\nimport { createEnv } from '@t3-oss/env-nextjs';\r\nimport { z } from 'zod';\r\n\r\nexport const getServerDBConfig = () => {\r\n  return createEnv({\r\n    client: {\r\n      NEXT_PUBLIC_ENABLED_SERVER_SERVICE: z.boolean(),\r\n    },\r\n    runtimeEnv: {\r\n      DATABASE_DRIVER: process.env.DATABASE_DRIVER || 'neon',\r\n      DATABASE_TEST_URL: process.env.DATABASE_TEST_URL,\r\n      DATABASE_URL: process.env.DATABASE_URL,\r\n\r\n      DISABLE_REMOVE_GLOBAL_FILE: process.env.DISABLE_REMOVE_GLOBAL_FILE === '1',\r\n\r\n      KEY_VAULTS_SECRET: process.env.KEY_VAULTS_SECRET,\r\n\r\n      NEXT_PUBLIC_ENABLED_SERVER_SERVICE: process.env.NEXT_PUBLIC_SERVICE_MODE === 'server',\r\n    },\r\n    server: {\r\n      DATABASE_DRIVER: z.enum(['neon', 'node']),\r\n      DATABASE_TEST_URL: z.string().optional(),\r\n      DATABASE_URL: z.string().optional(),\r\n\r\n      DISABLE_REMOVE_GLOBAL_FILE: z.boolean().optional(),\r\n\r\n      KEY_VAULTS_SECRET: z.string().optional(),\r\n    },\r\n  });\r\n};\r\n\r\nexport const serverDBEnv = getServerDBConfig();\r\n```\r\n\r\ngetServerDBConfig uses createEnv from [@t3-oss/env-nextjs](https://github.com/t3-oss/t3-env).\r\n\r\nFinally, neonDrizzle is returned from this function - getDBInstance().\r\n\r\n```\r\nconst client = new NeonPool({ connectionString });\r\nreturn neonDrizzle(client, { schema });\r\n```\r\n\r\nschema in the above code snippet is imported from `schemas/lobechat` file.\r\n\r\n# session.ts Schema\r\n\r\nSince Lobechat uses Drizzle, we picked [schema/lobechat/session.ts](https://github.com/lobehub/lobe-chat/blob/main/src/database/server/schemas/lobechat/session.ts)\r\nas an example.\r\n\r\nimports used are:\r\n\r\n```\r\nimport { boolean, integer, pgTable, text, unique, uniqueIndex, varchar } from 'drizzle-orm/pg-core';\r\nimport { createInsertSchema } from 'drizzle-zod';\r\n```\r\n\r\nSession table defined:\r\n\r\n```\r\nexport const sessions = pgTable(\r\n  'sessions',\r\n  {\r\n    id: text('id')\r\n      .$defaultFn(() => idGenerator('sessions'))\r\n      .primaryKey(),\r\n    slug: varchar('slug', { length: 100 })\r\n      .notNull()\r\n      .$defaultFn(() => randomSlug()),\r\n    title: text('title'),\r\n    description: text('description'),\r\n    avatar: text('avatar'),\r\n    backgroundColor: text('background_color'),\r\n\r\n    type: text('type', { enum: ['agent', 'group'] }).default('agent'),\r\n\r\n    userId: text('user_id')\r\n      .references(() => users.id, { onDelete: 'cascade' })\r\n      .notNull(),\r\n    groupId: text('group_id').references(() => sessionGroups.id, { onDelete: 'set null' }),\r\n    clientId: text('client_id'),\r\n    pinned: boolean('pinned').default(false),\r\n\r\n    createdAt: createdAt(),\r\n    updatedAt: updatedAt(),\r\n  },\r\n  (t) => ({\r\n    slugUserIdUnique: uniqueIndex('slug_user_id_unique').on(t.slug, t.userId),\r\n\r\n    clientIdUnique: unique('sessions_client_id_user_id_unique').on(t.clientId, t.userId),\r\n  }),\r\n);\r\n```\r\n\r\nYou also want to make sure to define your schema path in the [drizzle.config.ts](https://github.com/lobehub/lobe-chat/blob/main/drizzle.config.ts)",
    "code": "var Component=(()=>{var p=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of b(e))!f.call(t,i)&&i!==r&&s(t,i,{get:()=>e[i],enumerable:!(o=u(e,i))||o.enumerable});return t};var w=(t,e,r)=>(r=t!=null?p(m(t)):{},a(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),S=t=>a(s({},\"__esModule\",{value:!0}),t);var h=v((R,c)=>{c.exports=_jsx_runtime});var y={};g(y,{default:()=>d,frontmatter:()=>x});var n=w(h()),x={title:\"API Layer in LobeChat\"};function l(t){let e={a:\"a\",code:\"code\",h1:\"h1\",h2:\"h2\",h3:\"h3\",h4:\"h4\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",ul:\"ul\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"In this guide, you will learn the API layer used in \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/tree/main\",children:\"Lobe Chat\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:`\\u{1F92F} Lobe Chat is an open-source, modern-design AI chat framework. Supports\\r\nMulti AI Providers( OpenAI / Claude 3 / Gemini / Ollama / Azure / DeepSeek),\\r\nKnowledge Base (file upload / knowledge management / RAG ), Multi-Modals (Vision/TTS) and plugin system.\\r\nOne-click FREE deployment of your private ChatGPT/ Claude application.`}),`\n`,(0,n.jsx)(e.h1,{id:\"whats-api-layer\",children:\"What's API Layer?\"}),`\n`,(0,n.jsxs)(e.p,{children:[`In the context of web applications, API layer means communicating with your server to get/mutate data.\\r\nInspired by `,(0,n.jsx)(e.a,{href:\"https://github.com/alan2207/bulletproof-react/blob/master/docs/api-layer.md\",children:\"Bulletproof React's API Layer\"}),`\\r\nWe analyze the API Layer in the `,(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/tree/main\",children:\"Lobechat\"}),\".\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"lobe-chat-api-layer\",children:\"Lobe Chat API Layer\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To study the API Layer, we pick a page on \",(0,n.jsx)(e.a,{href:\"https://chat-preview.lobehub.com/\",children:\"https://chat-preview.lobehub.com/\"}),` and look at the source code except we are\\r\nnarrowing down our expedition to focus on the API Layer.`]}),`\n`,(0,n.jsx)(e.h1,{id:\"concepts-you-will-learn\",children:\"Concepts you will learn:\"}),`\n`,(0,n.jsx)(e.p,{children:`You will be learning the API layer used in the Lobe Chat.\\r\nRead through this guide to understand how Lobe Chat's API layer works.`}),`\n`,(0,n.jsx)(e.h2,{id:\"data-fetched-in-discover-home-page\",children:\"Data fetched in Discover Home Page\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`[Discover Home Page]\\r\n(`,(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/page.tsx\",children:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/page.tsx\"}),\")\"]}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L27\",children:\"DiscoverService\"})}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:`In this guide, we will find out how the API layer is implemented in Discover page. You will learn how the data is fetched\\r\nin the Discover page.`}),`\n`,(0,n.jsxs)(e.p,{children:[\"[Insert a screenshot of Discover page - \",(0,n.jsx)(e.a,{href:\"https://lobechat.com/discover\",children:\"https://lobechat.com/discover\"}),\"]\"]}),`\n`,(0,n.jsx)(e.p,{children:`Discover page has Home, Assistants, Plugins etc., tabs. For this guide, let's pick assistants tab and\\r\nfind out how the data is fetched.`}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/page.tsx\",children:\"Discover page.tsx\"}),`,\\r\nYou will find the below code snippet.`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`const discoverService = new DiscoverService();\\r\nconst assistantList = await discoverService.getAssistantList(locale);\\r\nconst pluginList = await discoverService.getPluginList(locale);\\r\nconst modelList = await discoverService.getModelList(locale);\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"discoverservice\",children:\"DiscoverService\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L52\",children:\"DiscoverService\"}),` is class that is\\r\ninstantiated using `,(0,n.jsx)(e.code,{children:\"new DiscoverService()\"}),`. You could also just export the functions from a service file but using a class\\r\nin a service helps you organize your functions better as your functions are encapsulated in a class. This approach also make it\\r\neasy to mock your service for testing purposes.`]}),`\n`,(0,n.jsx)(e.h3,{id:\"discoverservicegetassistantlistlocale\",children:\"discoverService.getAssistantList(locale)\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`getAssistantList = async (locale: Locales): Promise<DiscoverAssistantItem[]> => {\\r\n    let res = await fetch(this.assistantStore.getAgentIndexUrl(locale), {\\r\n      next: { revalidate },\\r\n    });\\r\n\\r\n    if (!res.ok) {\\r\n      res = await fetch(this.assistantStore.getAgentIndexUrl(DEFAULT_LANG), {\\r\n        next: { revalidate },\\r\n      });\\r\n    }\\r\n\\r\n    if (!res.ok) return [];\\r\n\\r\n    const json = await res.json();\\r\n\\r\n    return json.agents;\\r\n};\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This above code snippet is picked from \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L52\",children:\"getAssistantList\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This function uses \",(0,n.jsx)(e.a,{href:\"https://nextjs.org/docs/app/api-reference/functions/fetch\",children:\"fetch\"}),`. Next.js extends the native Web\\r\nfetch() API to allow each request on the server to set its own persistent caching semantics.`]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's understand what this second param in the above fetch does.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`{\\r\n  next: { revalidate },\\r\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://nextjs.org/docs/app/api-reference/functions/fetch#optionsnextrevalidate\",children:\"options.next.revalidate\"}),` from the\\r\nNext.js documentation.`]}),`\n`,(0,n.jsx)(e.p,{children:\"Set the cache lifetime of a resource (in seconds).\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"false - Cache the resource indefinitely. Semantically equivalent to revalidate: Infinity. The HTTP cache may evict older resources over time.\"}),`\n`,(0,n.jsx)(e.li,{children:\"0 - Prevent the resource from being cached.\"}),`\n`,(0,n.jsx)(e.li,{children:\"number - (in seconds) Specify the resource should have a cache lifetime of at most n seconds.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"so where's revalidate value coming from in \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L25\",children:\"Discover service\"}),`?\\r\nrevalidate is initialized at L25:`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`const revalidate: number = 3600;\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This 3600 is in seconds which is 1 hour. getAssistantList has a cache lifetime of at most 1 hour.\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"assistantStore.getAgentIndexUrl\"}),\" returns the URL used in the fetch API.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"[Insert a screenshot of \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/modules/AssistantStore/index.ts#L14\",children:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/modules/AssistantStore/index.ts#L14\"}),\"]\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"references\",children:\"References:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/page.tsx\",children:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/page.tsx\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/Client.tsx\",children:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/Client.tsx\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/features/AssistantList.tsx\",children:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/discover/(list)/(home)/features/AssistantList.tsx\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L28\",children:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/services/discover/index.ts#L28\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/modules/AssistantStore/index.ts\",children:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/modules/AssistantStore/index.ts\"})}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{id:\"data-fetched-in-chat-page\",children:\"Data fetched in Chat Page\"}),`\n`,(0,n.jsxs)(e.p,{children:[`Data fetched in the Chat page is different to what you have seen in getAssistantList in discover service.\\r\ngetAssistantList uses fetch, where as Chat uses `,(0,n.jsx)(e.code,{children:\"useSWR\"}),\". Let's find out how this is done.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"[insert screenshot of lobechat chat session page]\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"You will find useFetchSessions hook in \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/chat/%40session/features/SessionListContent/DefaultMode.tsx#L29\",children:\"SessionListContent/DefaultMode.tsx\"}),`\\r\nuseFetchSession is in useSessionStore. API layer is tightly coupled with state management in Lobechat. We want to focus\\r\nonly on API layer, check out the [state management in lobechat](link to lobechat state management).`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"[Insert screenshot of \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/chat/%40session/features/SessionListContent/DefaultMode.tsx#L29\",children:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/chat/%40session/features/SessionListContent/DefaultMode.tsx#L29\"}),\"]\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"usefetchsessions-in-session-store\",children:\"useFetchSessions in session store:\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"You will find the below code for the useFetchSessions in \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/store/session/slices/session/action.ts#L200\",children:\"session/action.ts\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`useFetchSessions: (isLogin) =>\\r\n    useClientDataSWR<ChatSessionList>(\\r\n      [FETCH_SESSIONS_KEY, isLogin],\\r\n      () => sessionService.getGroupedSessions(),\\r\n      {\\r\n        fallbackData: {\\r\n          sessionGroups: [],\\r\n          sessions: [],\\r\n        },\\r\n        onSuccess: (data) => {\\r\n          if (\\r\n            get().isSessionsFirstFetchFinished &&\\r\n            isEqual(get().sessions, data.sessions) &&\\r\n            isEqual(get().sessionGroups, data.sessionGroups)\\r\n          )\\r\n            return;\\r\n\\r\n          get().internal_processSessions(\\r\n            data.sessions,\\r\n            data.sessionGroups,\\r\n            n('useFetchSessions/updateData') as any,\\r\n          );\\r\n          set({ isSessionsFirstFetchFinished: true }, false, n('useFetchSessions/onSuccess', data));\\r\n        },\\r\n        suspense: true,\\r\n      },\\r\n    ),\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Looks compicated, let's break it down. It uses:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"useClientDataSWR\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"useClientDataSWR is imported from \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/libs/swr/index.ts#L22C14-L22C30\",children:\"libs/swr/index.ts\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`export const useClientDataSWR: SWRHook = (key, fetch, config) =>\\r\n  useSWR(key, fetch, {\\r\n    // default is 2000ms ,it makes the user's quick switch don't work correctly.\\r\n    // Cause issue like this: https://github.com/lobehub/lobe-chat/issues/532\\r\n    // we need to set it to 0.\\r\n    dedupingInterval: 0,\\r\n    focusThrottleInterval: 5 * 60 * 1000,\\r\n    refreshWhenOffline: false,\\r\n    revalidateOnFocus: true,\\r\n    revalidateOnReconnect: true,\\r\n    ...config,\\r\n  });\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"useSWR is a React hook for data fetching provided by \",(0,n.jsx)(e.a,{href:\"https://swr.vercel.app/\",children:\"Vercel's SWR API\"}),`.\\r\nThe name \\u201CSWR\\u201D is derived from stale-while-revalidate, a HTTP cache invalidation strategy popularized by\\r\nHTTP RFC 5861(opens in a new tab). SWR is a strategy to first return the data from cache (stale), then send\\r\nthe fetch request (revalidate), and finally come with the up-to-date data.`]}),`\n`,(0,n.jsx)(e.p,{children:`Let's now understand what each of these options do by referring to the documentation:\\r\na. dedupingInterval`}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://swr.vercel.app/docs/api#parameters\",children:\"SWR Docs\"}),\" mentions this - dedupingInterval = 2000: dedupe requests with the same key in this time span in milliseconds\"]}),`\n`,(0,n.jsx)(e.p,{children:\"but Lobechat has this configured to 0 and it explains why with a nice comment.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`// default is 2000ms ,it makes the user's quick switch don't work correctly.\\r\n// Cause issue like this: https://github.com/lobehub/lobe-chat/issues/532\\r\n// we need to set it to 0.\\r\ndedupingInterval: 0,\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"just in case, if you were wondering what dedupe means, it is about removing duplicates.\"}),`\n`,(0,n.jsx)(e.p,{children:\"b. focusThrottleInterval:\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://swr.vercel.app/docs/api#parameters\",children:\"SWR docs\"}),` provides this information about focusThrottleInterval -\\r\nfocusThrottleInterval = 5000: only revalidate once during a time span in milliseconds`]}),`\n`,(0,n.jsx)(e.p,{children:`In the context of useSWR, the focusThrottleInterval option controls how frequently the data revalidation\\r\nhappens when the window or tab regains focus.`}),`\n`,(0,n.jsx)(e.h3,{id:\"chatgpts-explanation\",children:\"ChatGPT's explanation:\"}),`\n`,(0,n.jsx)(e.p,{children:`Explanation in the useSWR context:\\r\nSWR's behavior with focus: By default, SWR will revalidate (i.e., refetch) the data whenever the user\\r\nswitches back to the app or tab (when the window or tab regains focus). This is useful because it ensures that\\r\nthe data displayed is up-to-date when the user returns to the app.`}),`\n`,(0,n.jsx)(e.p,{children:`focusThrottleInterval = 5000: This option tells SWR to throttle the revalidation when focus changes.\\r\nSpecifically, it will revalidate data at most once every 5000 milliseconds (or 5 seconds).`}),`\n`,(0,n.jsx)(e.p,{children:`If a user quickly switches between tabs or focuses on the app multiple times in rapid succession,\\r\nSWR will ensure that revalidation only happens once within that 5-second window, preventing excessive\\r\nor redundant requests.`}),`\n`,(0,n.jsx)(e.p,{children:\"What's the value that lobechat uses?\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`focusThrottleInterval: 5 * 60 * 1000\n`})}),`\n`,(0,n.jsx)(e.p,{children:`Converting 5 * 60 * 1000 milliseconds, it is 5 minutes. What this means is that when you focus by revisiting lobechat\\r\napplication, data is not refreshed until 5 minutes but by then you would visit different pages, differen chats\\r\nand latest data might load already but that depends on the actions that you perform.`}),`\n`,(0,n.jsx)(e.p,{children:\"c. refreshWhenOffline:\"}),`\n`,(0,n.jsx)(e.h3,{id:\"swr-documentation-explanation\",children:\"SWR documentation explanation:\"}),`\n`,(0,n.jsxs)(e.p,{children:[`refreshWhenOffline = false: polling when the browser is offline\\r\n(determined by navigator.onLine), Read more about `,(0,n.jsx)(e.a,{href:\"https://swr.vercel.app/docs/api#parameters\",children:\"refreshWhenOffline\"})]}),`\n`,(0,n.jsx)(e.h3,{id:\"chatgpt-explanation\",children:\"ChatGPT explanation:\"}),`\n`,(0,n.jsxs)(e.p,{children:[`SWR offers an option to periodically refetch data in the background (polling), but when the browser\\r\ngoes offline, trying to fetch data may be pointless. To prevent unnecessary requests, setting\\r\n`,(0,n.jsx)(e.code,{children:\"refreshWhenOffline = false\"}),` ensures polling is paused when the browser is offline,\\r\nsaving resources and avoiding failed fetch attempts.`]}),`\n`,(0,n.jsx)(e.h3,{id:\"whats-the-value-that-lobechat-uses\",children:\"What's the value that lobechat uses?\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`refreshWhenOffline: false\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"d. revalidateOnFocus:\"}),`\n`,(0,n.jsx)(e.h3,{id:\"swr-documentation-explanation-1\",children:\"SWR documentation explanation:\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"revalidateOnFocus = true: automatically revalidate when window gets focused (\",(0,n.jsx)(e.a,{href:\"https://swr.vercel.app/docs/revalidation\",children:\"details\"}),\")\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"chatgpt-explanation-1\",children:\"ChatGPT explanation:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:`Revalidate: In SWR, \"revalidate\" refers to refetching data from the source (e.g., an API)\\r\nto ensure the data is still up-to-date.`}),`\n`,(0,n.jsx)(e.li,{children:`Focus events: In web applications, a \"focus\" event occurs when the user returns to the browser window or tab,\\r\neither after switching tabs, windows, or after minimizing and reopening the app.`}),`\n`,(0,n.jsx)(e.li,{children:`revalidateOnFocus = true: This setting enables the app to automatically revalidate (refetch data) every time\\r\nthe user switches back to the tab. By default, this is set to true in SWR, meaning the data will be refreshed every time the tab regains focus.`}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"whats-the-value-that-lobechat-uses-1\",children:\"What's the value that lobechat uses?\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`revalidateOnFocus: true,\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"d. revalidateOnReconnect:\"}),`\n`,(0,n.jsx)(e.h3,{id:\"swr-documentation-explanation-2\",children:\"SWR documentation explanation:\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"revalidateOnReconnect = true: automatically revalidate when the browser regains a network connection (via navigator.onLine) (\",(0,n.jsx)(e.a,{href:\"https://swr.vercel.app/docs/revalidation\",children:\"details\"}),\")\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"chatgpt-explanation-2\",children:\"ChatGPT explanation:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Revalidate: In SWR, revalidation refers to refetching data from the server to ensure it's up-to-date.\"}),`\n`,(0,n.jsx)(e.li,{children:`Reconnect: This event happens when the browser loses and then regains internet connectivity. The browser\\r\ndetects this change using the navigator.onLine property:\\r\ntrue: Browser is online (connected to the internet).\\r\nfalse: Browser is offline (disconnected from the internet).`}),`\n`,(0,n.jsx)(e.li,{children:`revalidateOnReconnect = true: This setting ensures that whenever the browser switches from an offline state back to an\\r\nonline state, SWR will automatically refetch the data.`}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"whats-the-value-that-lobechat-uses-2\",children:\"What's the value that lobechat uses?\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`revalidateOnReconnect: true\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"params\",children:\"Params:\"}),`\n`,(0,n.jsx)(e.p,{children:\"Now that we understand useClientDataSWR and its options, let's look at the params used. The first param is the key\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`useClientDataSWR<ChatSessionList>(\\r\n      [FETCH_SESSIONS_KEY, isLogin],\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The second param is the fetch function written in \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/services/session/server.ts#L49\",children:\"sessionService.getGroupedSessions()\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Third params is the additional config passed to useClientDataSWR function.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"At this point, we are introduced to the new unknown \",(0,n.jsx)(e.code,{children:\"sessionService\"}),\". Let's analyze sessionService.\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"references-1\",children:\"References:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/app/(main)/chat/%40session/features/SessionListContent/DefaultMode.tsx#L29\",children:\"Session List\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/store/session/slices/session/action.ts#L200\",children:\"useFetchSessions\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/libs/swr/index.ts#L22C14-L22C30\",children:\"useClientDataSWR\"})}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"[C: sessionService]\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this guide, we analyze the \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/services/session/server.ts#L49\",children:\"sessionService\"}),`,\\r\nthat gets called in a store.`]}),`\n`,(0,n.jsx)(e.p,{children:\"The way we approach this is that we pick a function, understand it and see where it leads us.\"}),`\n`,(0,n.jsx)(e.h1,{id:\"getgroupedsessions\",children:\"getGroupedSessions()\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/services/session/server.ts#L49\",children:\"getGroupedSessions()\"}),` has the below\\r\ncode:`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`getGroupedSessions(): Promise<ChatSessionList> {\\r\n  return lambdaClient.session.getGroupedSessions.query();\\r\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:`The unknown here is lambdaClient. What could this be about? to find that out, you have to see where\\r\nlambdaClient is imported from.`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`import { lambdaClient } from '@/libs/trpc/client';\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"lambdaClient is imported from \",(0,n.jsx)(e.code,{children:\"@libs/trpc/client\"}),\". This tells us that Lobechat uses tRPC. What's TRPC?\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"trpc\",children:\"tRPC\"}),`\n`,(0,n.jsx)(e.p,{children:\"Move fast and break nothing. tRPC provides end-to-end typesafe APIs for your fullstack application.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since Lobechat uses app router, you may want to read this \",(0,n.jsx)(e.a,{href:\"https://trpc.io/docs/client/react/server-components\",children:\"set up with React components guide\"}),`\\r\nto understand how the tRPC is configured in Lobechat codebase.`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We refer to the steps provided in \",(0,n.jsx)(e.a,{href:\"https://trpc.io/docs/client/react/server-components\",children:\"tRPC Setup with React Components\"}),`\\r\nand find out how Lobechat configured tRPC.`]}),`\n`,(0,n.jsx)(e.p,{children:\"Useful links:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://trpc.io/\",children:\"tRPC\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://trpc.io/docs/quickstart\",children:\"tRPC quick start\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://trpc.io/docs/client/nextjs/setup\",children:\"Next.js, pages router + tRPC setup\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://trpc.io/docs/client/react/server-components\",children:\"Next.js, app router + tRPC setup\"})}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{id:\"dependencies-required\",children:\"Dependencies required\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://trpc.io/docs/client/react/server-components#1-install-deps\",children:\"tRPC docs\"}),` tells us to install the\\r\nfollowing dependencies in your project:`]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"@trpc/server@next\"}),`\n`,(0,n.jsx)(e.li,{children:\"@trpc/client@next\"}),`\n`,(0,n.jsx)(e.li,{children:\"@trpc/react-query@next\"}),`\n`,(0,n.jsx)(e.li,{children:\"@tanstack/react-query@latest\"}),`\n`,(0,n.jsx)(e.li,{children:\"zod\"}),`\n`,(0,n.jsx)(e.li,{children:\"client-only\"}),`\n`,(0,n.jsx)(e.li,{children:\"server-only\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Lobechat has the following packages installed, available in \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/package.json\",children:\"package.json\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`\"@tanstack/react-query\": \"^5.59.15\",\\r\n\"@trpc/client\": \"next\",\\r\n\"@trpc/next\": \"next\",\\r\n\"@trpc/react-query\": \"next\",\\r\n\"@trpc/server\": \"next\",\\r\n\"zod\": \"^3.23.8\",\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"There is no 'client-only', 'server-only' packages in Lobechat package.json and has a package named \",(0,n.jsx)(e.code,{children:\"@trpc/next\"}),\" installed.\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"create-a-trpc-router\",children:\"Create a tRPC router\"}),`\n`,(0,n.jsx)(e.h3,{id:\"trpc-documentation-summary\",children:\"tRPC Documentation summary\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"You would need create a tRPC router as explained in \",(0,n.jsx)(e.a,{href:\"https://trpc.io/docs/client/react/server-components#2-create-a-trpc-router\",children:\"tRPC docs\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"You create the following files:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"trpc/init.ts\"}),`\n`,(0,n.jsx)(e.li,{children:\"trpc/routers/_app.ts\"}),`\n`,(0,n.jsx)(e.li,{children:\"app/api/trpc/[trpc]/route.ts\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"lobechat-implementation\",children:\"Lobechat implementation:\"}),`\n`,(0,n.jsx)(e.h4,{id:\"initts\",children:\"init.ts\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"You will find init.ts in \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/libs/trpc/init.ts\",children:\"src/libs/trpc/init.ts\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`export const trpc = initTRPC.context<Context>().create({\\r\n  /**\\r\n   * @link https://trpc.io/docs/v11/error-formatting\\r\n   */\\r\n  errorFormatter({ shape }) {\\r\n    return shape;\\r\n  },\\r\n  /**\\r\n   * @link https://trpc.io/docs/v11/data-transformers\\r\n   */\\r\n  transformer: superjson,\\r\n});\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Only tRPC is exported, but if you were to look at init.ts provided in documentation, it has the below code:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`const t = initTRPC.create({\\r\n  /**\\r\n   * @see https://trpc.io/docs/server/data-transformers\\r\n   */\\r\n  // transformer: superjson,\\r\n});\\r\n// Base router and procedure helpers\\r\nexport const createTRPCRouter = t.router;\\r\nexport const baseProcedure = t.procedure;\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Examples provided in documentation exports router and procedure but Lobechat only exports \",(0,n.jsx)(e.code,{children:\"trpc\"}),\" which is \",(0,n.jsx)(e.code,{children:\"t\"}),` in tRPC\\r\ndocumentation example.`]}),`\n`,(0,n.jsx)(e.h4,{id:\"routers\",children:\"routers\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the tRPC documentation, routers are defined in \",(0,n.jsx)(e.code,{children:\"trpc/routers/_app.ts\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`import { z } from 'zod';\\r\nimport { baseProcedure, createTRPCRouter } from '../init';\\r\nexport const appRouter = createTRPCRouter({\\r\n  hello: baseProcedure\\r\n    .input(\\r\n      z.object({\\r\n        text: z.string(),\\r\n      }),\\r\n    )\\r\n    .query((opts) => {\\r\n      return {\\r\n        greeting: \\`hello \\${opts.input.text}\\`,\\r\n      };\\r\n    }),\\r\n});\\r\n// export type definition of API\\r\nexport type AppRouter = typeof appRouter;\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Lobechat has a folder named routers in \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/tree/main/src/server/routers\",children:\"server folder\"}),`,\\r\nWe chose `,(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/routers/lambda/session.ts\",children:\"lambda/session.ts\"}),` inside\\r\nserver folder for explanation in this guide.`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"For you to register a route, you need trpc.router. This is imported from \",(0,n.jsx)(e.code,{children:\"@/lib/trpc\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`import { authedProcedure, publicProcedure, router } from '@/libs/trpc';\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For example, \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/routers/lambda/session.ts#L92\",children:\"getSessions\"}),`\\r\nis registered with the router as shown below:`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`getSessions: sessionProcedure\\r\n    .input(\\r\n      z.object({\\r\n        current: z.number().optional(),\\r\n        pageSize: z.number().optional(),\\r\n      }),\\r\n    )\\r\n    .query(async ({ input, ctx }) => {\\r\n      const { current, pageSize } = input;\\r\n\\r\n      return ctx.sessionModel.query({ current, pageSize });\\r\n    }),\n`})}),`\n`,(0,n.jsx)(e.p,{children:`we have now been introduced to sessionModel that makes the database calls, we will learn more about sessionModel in the\\r\nnext article.`}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/server/routers/lambda/session.ts#L13\",children:\"sessionProcedure\"}),` is defined\\r\nafter the imports in lambda/session.ts as shown below:`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`const sessionProcedure = authedProcedure.use(async (opts) => {\\r\n  const { ctx } = opts;\\r\n\\r\n  return opts.next({\\r\n    ctx: {\\r\n      sessionGroupModel: new SessionGroupModel(ctx.userId),\\r\n      sessionModel: new SessionModel(ctx.userId),\\r\n    },\\r\n  });\\r\n});\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"authedProcedure is from \",(0,n.jsx)(e.code,{children:\"@libs/trpc\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`// procedure that asserts that the user is logged in\\r\nexport const authedProcedure = trpc.procedure.use(userAuth);\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"[C: SessionModel]\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Based on the example, getSessions, we picked in the previous article, \",(0,n.jsx)(e.code,{children:\"sessionModel.query\"}),\" is used. \",(0,n.jsx)(e.code,{children:\"query\"}),` function in\\r\nsessionModel has the below code:`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`async query({ current = 0, pageSize = 9999 } = {}) {\\r\n    const offset = current * pageSize;\\r\n\\r\n    return serverDB.query.sessions.findMany({\\r\n      limit: pageSize,\\r\n      offset,\\r\n      orderBy: [desc(sessions.updatedAt)],\\r\n      where: and(eq(sessions.userId, this.userId), not(eq(sessions.slug, INBOX_SESSION_ID))),\\r\n      with: { agentsToSessions: { columns: {}, with: { agent: true } }, group: true },\\r\n    });\\r\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Unknown here is serverDB. serverDB is imported from \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/database/server/core/db.ts\",children:\"database/server/core/db\"}),\";\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`import { serverDB } from '@/database/server/core/db';\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"In Lobechat's tRPC procedures, models are used as an abstraction instead of directly dealing with database calls.\"}),`\n`,(0,n.jsx)(e.p,{children:\"[C: Database Core API]\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the previous chapter, we learnt that model uses serverDB imported from \",(0,n.jsx)(e.code,{children:\"@/database/server/core/db\"}),`. In this chapter, we\\r\nanalyze the Lobechat's database core API.`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The below imports are picked from \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/database/server/core/db.ts\",children:\"database/server/core/db.ts\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`import { Pool as NeonPool, neonConfig } from '@neondatabase/serverless';\\r\nimport { NeonDatabase, drizzle as neonDrizzle } from 'drizzle-orm/neon-serverless';\\r\nimport { drizzle as nodeDrizzle } from 'drizzle-orm/node-postgres';\\r\nimport { Pool as NodePool } from 'pg';\\r\nimport ws from 'ws';\\r\n\\r\nimport { serverDBEnv } from '@/config/db';\\r\nimport { isServerMode } from '@/const/version';\\r\n\\r\nimport * as schema from '../schemas/lobechat';\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You can tell from the imports that Lobechat uses \",(0,n.jsx)(e.a,{href:\"https://orm.drizzle.team/\",children:\"Drizzle ORM\"}),\" and \",(0,n.jsx)(e.a,{href:\"https://neon.tech/\",children:\"Neon database\"}),`.\\r\nCheck out this `,(0,n.jsx)(e.a,{href:\"https://orm.drizzle.team/docs/tutorials/drizzle-with-neon\",children:\"Drizzle with Neon tutorial\"}),` to find out more.\\r\nThis tutorial shows how to connect to Neon database using Drizzle.`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`import { drizzle } from \"drizzle-orm/neon-http\";\\r\nimport { neon } from \"@neondatabase/serverless\";\\r\nimport { config } from \"dotenv\";\\r\nconfig({ path: \".env\" }); // or .env.local\\r\nconst sql = neon(process.env.DATABASE_URL!);\\r\nexport const db = drizzle({ client: sql });\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Lobechat has additional checks as to which drizzle ORM is used. For example, in the below code:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`if (serverDBEnv.DATABASE_DRIVER === 'node') {\\r\n    const client = new NodePool({ connectionString });\\r\n    return nodeDrizzle(client, { schema });\\r\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"nodeDrizzle here is imported from \",(0,n.jsx)(e.code,{children:\"drizzle-orm/node-postgres\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"serverDBenv is imported from config/db.ts\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`import { createEnv } from '@t3-oss/env-nextjs';\\r\nimport { z } from 'zod';\\r\n\\r\nexport const getServerDBConfig = () => {\\r\n  return createEnv({\\r\n    client: {\\r\n      NEXT_PUBLIC_ENABLED_SERVER_SERVICE: z.boolean(),\\r\n    },\\r\n    runtimeEnv: {\\r\n      DATABASE_DRIVER: process.env.DATABASE_DRIVER || 'neon',\\r\n      DATABASE_TEST_URL: process.env.DATABASE_TEST_URL,\\r\n      DATABASE_URL: process.env.DATABASE_URL,\\r\n\\r\n      DISABLE_REMOVE_GLOBAL_FILE: process.env.DISABLE_REMOVE_GLOBAL_FILE === '1',\\r\n\\r\n      KEY_VAULTS_SECRET: process.env.KEY_VAULTS_SECRET,\\r\n\\r\n      NEXT_PUBLIC_ENABLED_SERVER_SERVICE: process.env.NEXT_PUBLIC_SERVICE_MODE === 'server',\\r\n    },\\r\n    server: {\\r\n      DATABASE_DRIVER: z.enum(['neon', 'node']),\\r\n      DATABASE_TEST_URL: z.string().optional(),\\r\n      DATABASE_URL: z.string().optional(),\\r\n\\r\n      DISABLE_REMOVE_GLOBAL_FILE: z.boolean().optional(),\\r\n\\r\n      KEY_VAULTS_SECRET: z.string().optional(),\\r\n    },\\r\n  });\\r\n};\\r\n\\r\nexport const serverDBEnv = getServerDBConfig();\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"getServerDBConfig uses createEnv from \",(0,n.jsx)(e.a,{href:\"https://github.com/t3-oss/t3-env\",children:\"@t3-oss/env-nextjs\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Finally, neonDrizzle is returned from this function - getDBInstance().\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`const client = new NeonPool({ connectionString });\\r\nreturn neonDrizzle(client, { schema });\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"schema in the above code snippet is imported from \",(0,n.jsx)(e.code,{children:\"schemas/lobechat\"}),\" file.\"]}),`\n`,(0,n.jsx)(e.h1,{id:\"sessionts-schema\",children:\"session.ts Schema\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since Lobechat uses Drizzle, we picked \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/src/database/server/schemas/lobechat/session.ts\",children:\"schema/lobechat/session.ts\"}),`\\r\nas an example.`]}),`\n`,(0,n.jsx)(e.p,{children:\"imports used are:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`import { boolean, integer, pgTable, text, unique, uniqueIndex, varchar } from 'drizzle-orm/pg-core';\\r\nimport { createInsertSchema } from 'drizzle-zod';\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Session table defined:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`export const sessions = pgTable(\\r\n  'sessions',\\r\n  {\\r\n    id: text('id')\\r\n      .$defaultFn(() => idGenerator('sessions'))\\r\n      .primaryKey(),\\r\n    slug: varchar('slug', { length: 100 })\\r\n      .notNull()\\r\n      .$defaultFn(() => randomSlug()),\\r\n    title: text('title'),\\r\n    description: text('description'),\\r\n    avatar: text('avatar'),\\r\n    backgroundColor: text('background_color'),\\r\n\\r\n    type: text('type', { enum: ['agent', 'group'] }).default('agent'),\\r\n\\r\n    userId: text('user_id')\\r\n      .references(() => users.id, { onDelete: 'cascade' })\\r\n      .notNull(),\\r\n    groupId: text('group_id').references(() => sessionGroups.id, { onDelete: 'set null' }),\\r\n    clientId: text('client_id'),\\r\n    pinned: boolean('pinned').default(false),\\r\n\\r\n    createdAt: createdAt(),\\r\n    updatedAt: updatedAt(),\\r\n  },\\r\n  (t) => ({\\r\n    slugUserIdUnique: uniqueIndex('slug_user_id_unique').on(t.slug, t.userId),\\r\n\\r\n    clientIdUnique: unique('sessions_client_id_user_id_unique').on(t.clientId, t.userId),\\r\n  }),\\r\n);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You also want to make sure to define your schema path in the \",(0,n.jsx)(e.a,{href:\"https://github.com/lobehub/lobe-chat/blob/main/drizzle.config.ts\",children:\"drizzle.config.ts\"})]})]})}function d(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(l,{...t})}):l(t)}return S(y);})();\n;return Component;"
  },
  "_id": "guide/codebase-architecture/lobechat/api-layer/introduction.mdx",
  "_raw": {
    "sourceFilePath": "guide/codebase-architecture/lobechat/api-layer/introduction.mdx",
    "sourceFileName": "introduction.mdx",
    "sourceFileDir": "guide/codebase-architecture/lobechat/api-layer",
    "contentType": "mdx",
    "flattenedPath": "guide/codebase-architecture/lobechat/api-layer/introduction"
  },
  "type": "Doc",
  "slug": "/guide/codebase-architecture/lobechat/api-layer/introduction",
  "slugAsParams": "codebase-architecture/lobechat/api-layer/introduction"
}