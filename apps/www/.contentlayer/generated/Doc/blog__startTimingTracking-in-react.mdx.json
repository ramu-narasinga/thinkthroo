{
<<<<<<< HEAD
  "title": "startTimingTracking in react-scan source code.\r",
=======
  "title": "startTimingTracking in react-scan source code.",
>>>>>>> 442b740f3cf43317109944c6cf4b7ca543a8cddf
  "published": false,
  "featured": false,
  "component": false,
  "toc": true,
  "body": {
<<<<<<< HEAD
    "raw": "\r\nIn this article, we review the below code snippet picked from [event-tracking.ts](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L364)\r\n\r\n```plaintext\r\nexport const startTimingTracking = () => {\r\n  const unSubPerformance = setupPerformancePublisher();\r\n  const unSubDirtyTaskTracking = startDirtyTaskTracking();\r\n  const unSubLongPipelineTracking = startLongPipelineTracking();\r\n\r\n  const onComplete = async (\r\n    _: string,\r\n    finalInteraction: FinalInteraction,\r\n    event: PerformanceEntryChannelEvent,\r\n  ) => {\r\n    toolbarEventStore.getState().actions.addEvent({\r\n      kind: 'interaction',\r\n      id: not_globally_unique_generateId(),\r\n      data: {\r\n        startAt: finalInteraction.detailedTiming.blockingTimeStart,\r\n        endAt: performance.now() + performance.timeOrigin,\r\n        meta: { ...finalInteraction, kind: event.kind }, // TODO, will need interaction specific metadata here\r\n      },\r\n    });\r\n\r\n    const existingCompletedInteractions =\r\n      performanceEntryChannels.getChannelState('recording');\r\n\r\n    finalInteraction.detailedTiming.stopListeningForRenders();\r\n\r\n    if (existingCompletedInteractions.length) {\r\n      // then performance entry and our detailed timing handlers are out of sync, we disregard that entry\r\n      // it may be possible the performance entry returned before detailed timing. If that's the case we should update\r\n      // assumptions and deal with mapping the entry back to the detailed timing here\r\n      performanceEntryChannels.updateChannelState(\r\n        'recording',\r\n        () => new BoundedArray(MAX_CHANNEL_SIZE),\r\n      );\r\n    }\r\n  };\r\n  const unSubDetailedPointerTiming = setupDetailedPointerTimingListener(\r\n    'pointer',\r\n    {\r\n      onComplete,\r\n    },\r\n  );\r\n  const unSubDetailedKeyboardTiming = setupDetailedPointerTimingListener(\r\n    'keyboard',\r\n    {\r\n      onComplete,\r\n    },\r\n  );\r\n\r\n  const unSubInteractions = listenForPerformanceEntryInteractions(\r\n    (completedInteraction) => {\r\n      interactionStore.setState(\r\n        BoundedArray.fromArray(\r\n          interactionStore.getCurrentState().concat(completedInteraction),\r\n          MAX_INTERACTION_BATCH,\r\n        ),\r\n      );\r\n    },\r\n  );\r\n\r\n  return () => {\r\n    unSubDirtyTaskTracking();\r\n    unSubLongPipelineTracking();\r\n    unSubPerformance();\r\n    unSubDetailedPointerTiming();\r\n    unSubInteractions();\r\n    unSubDetailedKeyboardTiming();\r\n  };\r\n};\r\n```\r\n\r\nLet’s go over this function in chunks.\r\n\r\n```plaintext\r\nconst unSubPerformance = setupPerformancePublisher();\r\nconst unSubDirtyTaskTracking = startDirtyTaskTracking();\r\nconst unSubLongPipelineTracking = startLongPipelineTracking();\r\n```\r\n\r\nthis calls three functions — setupPerformancePublisher, startDirtyTaskTracking, startLongPipelineTracking.\r\n\r\nstartDirtyTaskTracking and startLongPipelineTracking are defined in the same event-tracking.ts file except for the setupPerformancePublisher which is imported from [core/notifications/performance.ts](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333).\r\n\r\n> If there is one thing that I noticed, it is the cleanup involved across the react-scan codebase to avoid memory leaks.\r\n\r\n![](https://cdn-images-1.medium.com/max/1000/1*lzkeqQJsvALHF4CPpJrftQ.png)\r\n\r\n### onComplete function:\r\n\r\n```plaintext\r\nconst onComplete = async (\r\n    _: string,\r\n    finalInteraction: FinalInteraction,\r\n    event: PerformanceEntryChannelEvent,\r\n  ) => {\r\n    toolbarEventStore.getState().actions.addEvent({\r\n      kind: 'interaction',\r\n      id: not_globally_unique_generateId(),\r\n      data: {\r\n        startAt: finalInteraction.detailedTiming.blockingTimeStart,\r\n        endAt: performance.now() + performance.timeOrigin,\r\n        meta: { ...finalInteraction, kind: event.kind }, // TODO, will need interaction specific metadata here\r\n      },\r\n    });\r\n\r\n    const existingCompletedInteractions =\r\n      performanceEntryChannels.getChannelState('recording');\r\n\r\n    finalInteraction.detailedTiming.stopListeningForRenders();\r\n\r\n    if (existingCompletedInteractions.length) {\r\n      // then performance entry and our detailed timing handlers are out of sync, we disregard that entry\r\n      // it may be possible the performance entry returned before detailed timing. If that's the case we should update\r\n      // assumptions and deal with mapping the entry back to the detailed timing here\r\n      performanceEntryChannels.updateChannelState(\r\n        'recording',\r\n        () => new BoundedArray(MAX_CHANNEL_SIZE),\r\n      );\r\n    }\r\n  };\r\n```\r\n\r\nthis onComplete arrow function is defined in startTimingTracking. There’s an “interaction” event added and then there is this comment explaining what that if block is about:\r\n\r\n```plaintext\r\n// then performance entry and our detailed timing handlers are out of sync, we disregard that entry\r\n// it may be possible the performance entry returned before detailed timing. If that's the case we should update\r\n// assumptions and deal with mapping the entry back to the detailed timing here\r\n```\r\n\r\n```plaintext\r\nconst unSubDetailedPointerTiming = setupDetailedPointerTimingListener(\r\n    'pointer',\r\n    {\r\n      onComplete,\r\n    },\r\n  );\r\n  const unSubDetailedKeyboardTiming = setupDetailedPointerTimingListener(\r\n    'keyboard',\r\n    {\r\n      onComplete,\r\n    },\r\n  );\r\n\r\n  const unSubInteractions = listenForPerformanceEntryInteractions(\r\n    (completedInteraction) => {\r\n      interactionStore.setState(\r\n        BoundedArray.fromArray(\r\n          interactionStore.getCurrentState().concat(completedInteraction),\r\n          MAX_INTERACTION_BATCH,\r\n        ),\r\n      );\r\n    },\r\n  );\r\n```\r\n\r\nThese 2 functions — setupDetailedPointerTimingListener and listenForPerformanceEntryInteractions are defined in [performance.ts](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333)\r\n\r\n```plaintext\r\nreturn () => {\r\n    unSubDirtyTaskTracking();\r\n    unSubLongPipelineTracking();\r\n    unSubPerformance();\r\n    unSubDetailedPointerTiming();\r\n    unSubInteractions();\r\n    unSubDetailedKeyboardTiming();\r\n  };\r\n```\r\n\r\nThis function in the end returns an arrow function that triggers unsubscription/cleanup.\r\n\r\n### About me:\r\n\r\nHey, my name is [Ramu Narasinga](https://ramunarasinga.com). I study large open-source projects and create content about their codebase architecture and best practices, sharing it through articles, videos.\r\n\r\n***I am open to work on interesting projects. Send me an email at ramu.narasinga@gmail.com***\r\n\r\nMy Github —  [https://github.com/ramu-narasinga](https://github.com/ramu-narasinga)\r\n\r\nMy website —  [https://ramunarasinga.com](https://ramunarasinga.com/)\r\n\r\nMy Youtube channel —  [https://www.youtube.com/@thinkthroo](https://www.youtube.com/@thinkthroo)\r\n\r\nLearning platform —  [https://thinkthroo.com](https://thinkthroo.com/)\r\n\r\nCodebase Architecture —  [https://app.thinkthroo.com/architecture](https://app.thinkthroo.com/architecture)\r\n\r\nBest practices —  [https://app.thinkthroo.com/best-practices](https://app.thinkthroo.com/best-practices)\r\n\r\nProduction-grade projects —  [https://app.thinkthroo.com/production-grade-projects](https://app.thinkthroo.com/production-grade-projects)\r\n\r\n### References:\r\n\r\n1. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L364](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L364)\r\n    \r\n2. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L365](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L365)\r\n    \r\n3. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L423](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L423)\r\n    \r\n4. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333)\r\n    \r\n5. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333)",
=======
    "raw": "\nIn this article, we review the below code snippet picked from [event-tracking.ts](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L364)\n\n```plaintext\nexport const startTimingTracking = () => {\n  const unSubPerformance = setupPerformancePublisher();\n  const unSubDirtyTaskTracking = startDirtyTaskTracking();\n  const unSubLongPipelineTracking = startLongPipelineTracking();\n\n  const onComplete = async (\n    _: string,\n    finalInteraction: FinalInteraction,\n    event: PerformanceEntryChannelEvent,\n  ) => {\n    toolbarEventStore.getState().actions.addEvent({\n      kind: 'interaction',\n      id: not_globally_unique_generateId(),\n      data: {\n        startAt: finalInteraction.detailedTiming.blockingTimeStart,\n        endAt: performance.now() + performance.timeOrigin,\n        meta: { ...finalInteraction, kind: event.kind }, // TODO, will need interaction specific metadata here\n      },\n    });\n\n    const existingCompletedInteractions =\n      performanceEntryChannels.getChannelState('recording');\n\n    finalInteraction.detailedTiming.stopListeningForRenders();\n\n    if (existingCompletedInteractions.length) {\n      // then performance entry and our detailed timing handlers are out of sync, we disregard that entry\n      // it may be possible the performance entry returned before detailed timing. If that's the case we should update\n      // assumptions and deal with mapping the entry back to the detailed timing here\n      performanceEntryChannels.updateChannelState(\n        'recording',\n        () => new BoundedArray(MAX_CHANNEL_SIZE),\n      );\n    }\n  };\n  const unSubDetailedPointerTiming = setupDetailedPointerTimingListener(\n    'pointer',\n    {\n      onComplete,\n    },\n  );\n  const unSubDetailedKeyboardTiming = setupDetailedPointerTimingListener(\n    'keyboard',\n    {\n      onComplete,\n    },\n  );\n\n  const unSubInteractions = listenForPerformanceEntryInteractions(\n    (completedInteraction) => {\n      interactionStore.setState(\n        BoundedArray.fromArray(\n          interactionStore.getCurrentState().concat(completedInteraction),\n          MAX_INTERACTION_BATCH,\n        ),\n      );\n    },\n  );\n\n  return () => {\n    unSubDirtyTaskTracking();\n    unSubLongPipelineTracking();\n    unSubPerformance();\n    unSubDetailedPointerTiming();\n    unSubInteractions();\n    unSubDetailedKeyboardTiming();\n  };\n};\n```\n\nLet’s go over this function in chunks.\n\n```plaintext\nconst unSubPerformance = setupPerformancePublisher();\nconst unSubDirtyTaskTracking = startDirtyTaskTracking();\nconst unSubLongPipelineTracking = startLongPipelineTracking();\n```\n\nthis calls three functions — setupPerformancePublisher, startDirtyTaskTracking, startLongPipelineTracking.\n\nstartDirtyTaskTracking and startLongPipelineTracking are defined in the same event-tracking.ts file except for the setupPerformancePublisher which is imported from [core/notifications/performance.ts](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333).\n\n> If there is one thing that I noticed, it is the cleanup involved across the react-scan codebase to avoid memory leaks.\n\n![](https://cdn-images-1.medium.com/max/1000/1*lzkeqQJsvALHF4CPpJrftQ.png)\n\n### onComplete function:\n\n```plaintext\nconst onComplete = async (\n    _: string,\n    finalInteraction: FinalInteraction,\n    event: PerformanceEntryChannelEvent,\n  ) => {\n    toolbarEventStore.getState().actions.addEvent({\n      kind: 'interaction',\n      id: not_globally_unique_generateId(),\n      data: {\n        startAt: finalInteraction.detailedTiming.blockingTimeStart,\n        endAt: performance.now() + performance.timeOrigin,\n        meta: { ...finalInteraction, kind: event.kind }, // TODO, will need interaction specific metadata here\n      },\n    });\n\n    const existingCompletedInteractions =\n      performanceEntryChannels.getChannelState('recording');\n\n    finalInteraction.detailedTiming.stopListeningForRenders();\n\n    if (existingCompletedInteractions.length) {\n      // then performance entry and our detailed timing handlers are out of sync, we disregard that entry\n      // it may be possible the performance entry returned before detailed timing. If that's the case we should update\n      // assumptions and deal with mapping the entry back to the detailed timing here\n      performanceEntryChannels.updateChannelState(\n        'recording',\n        () => new BoundedArray(MAX_CHANNEL_SIZE),\n      );\n    }\n  };\n```\n\nthis onComplete arrow function is defined in startTimingTracking. There’s an “interaction” event added and then there is this comment explaining what that if block is about:\n\n```plaintext\n// then performance entry and our detailed timing handlers are out of sync, we disregard that entry\n// it may be possible the performance entry returned before detailed timing. If that's the case we should update\n// assumptions and deal with mapping the entry back to the detailed timing here\n```\n\n```plaintext\nconst unSubDetailedPointerTiming = setupDetailedPointerTimingListener(\n    'pointer',\n    {\n      onComplete,\n    },\n  );\n  const unSubDetailedKeyboardTiming = setupDetailedPointerTimingListener(\n    'keyboard',\n    {\n      onComplete,\n    },\n  );\n\n  const unSubInteractions = listenForPerformanceEntryInteractions(\n    (completedInteraction) => {\n      interactionStore.setState(\n        BoundedArray.fromArray(\n          interactionStore.getCurrentState().concat(completedInteraction),\n          MAX_INTERACTION_BATCH,\n        ),\n      );\n    },\n  );\n```\n\nThese 2 functions — setupDetailedPointerTimingListener and listenForPerformanceEntryInteractions are defined in [performance.ts](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333)\n\n```plaintext\nreturn () => {\n    unSubDirtyTaskTracking();\n    unSubLongPipelineTracking();\n    unSubPerformance();\n    unSubDetailedPointerTiming();\n    unSubInteractions();\n    unSubDetailedKeyboardTiming();\n  };\n```\n\nThis function in the end returns an arrow function that triggers unsubscription/cleanup.\n\n### About me:\n\nHey, my name is [Ramu Narasinga](https://ramunarasinga.com). I study large open-source projects and create content about their codebase architecture and best practices, sharing it through articles, videos.\n\n***I am open to work on interesting projects. Send me an email at ramu.narasinga@gmail.com***\n\nMy Github —  [https://github.com/ramu-narasinga](https://github.com/ramu-narasinga)\n\nMy website —  [https://ramunarasinga.com](https://ramunarasinga.com/)\n\nMy Youtube channel —  [https://www.youtube.com/@thinkthroo](https://www.youtube.com/@thinkthroo)\n\nLearning platform —  [https://thinkthroo.com](https://thinkthroo.com/)\n\nCodebase Architecture —  [https://app.thinkthroo.com/architecture](https://app.thinkthroo.com/architecture)\n\nBest practices —  [https://app.thinkthroo.com/best-practices](https://app.thinkthroo.com/best-practices)\n\nProduction-grade projects —  [https://app.thinkthroo.com/production-grade-projects](https://app.thinkthroo.com/production-grade-projects)\n\n### References:\n\n1. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L364](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L364)\n    \n2. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L365](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L365)\n    \n3. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L423](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L423)\n    \n4. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333)\n    \n5. [https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333](https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333)",
>>>>>>> 442b740f3cf43317109944c6cf4b7ca543a8cddf
    "code": "var Component=(()=>{var o=Object.create;var c=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,N=Object.prototype.hasOwnProperty;var f=(a,n)=>()=>(n||a((n={exports:{}}).exports,n),n.exports),b=(a,n)=>{for(var i in n)c(a,i,{get:n[i],enumerable:!0})},l=(a,n,i,r)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let s of g(n))!N.call(a,s)&&s!==i&&c(a,s,{get:()=>n[s],enumerable:!(r=m(n,s))||r.enumerable});return a};var y=(a,n,i)=>(i=a!=null?o(u(a)):{},l(n||!a||!a.__esModule?c(i,\"default\",{value:a,enumerable:!0}):i,a)),k=a=>l(c({},\"__esModule\",{value:!0}),a);var d=f((P,t)=>{t.exports=_jsx_runtime});var S={};b(S,{default:()=>p,frontmatter:()=>T});var e=y(d()),T={title:\"startTimingTracking in react-scan source\\xA0code.\"};function h(a){let n={a:\"a\",blockquote:\"blockquote\",code:\"code\",div:\"div\",em:\"em\",h3:\"h3\",img:\"img\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",span:\"span\",strong:\"strong\",...a.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"In this article, we review the below code snippet picked from \",(0,e.jsx)(n.a,{href:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L364\",children:\"event-tracking.ts\"})]}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,e.jsxs)(n.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"export const startTimingTracking = () => {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  const unSubPerformance = setupPerformancePublisher();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  const unSubDirtyTaskTracking = startDirtyTaskTracking();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  const unSubLongPipelineTracking = startLongPipelineTracking();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  const onComplete = async (\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    _: string,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    finalInteraction: FinalInteraction,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    event: PerformanceEntryChannelEvent,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  ) => {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    toolbarEventStore.getState().actions.addEvent({\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      kind: 'interaction',\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      id: not_globally_unique_generateId(),\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      data: {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        startAt: finalInteraction.detailedTiming.blockingTimeStart,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        endAt: performance.now() + performance.timeOrigin,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        meta: { ...finalInteraction, kind: event.kind }, // TODO, will need interaction specific metadata here\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      },\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    });\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    const existingCompletedInteractions =\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      performanceEntryChannels.getChannelState('recording');\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    finalInteraction.detailedTiming.stopListeningForRenders();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    if (existingCompletedInteractions.length) {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      // then performance entry and our detailed timing handlers are out of sync, we disregard that entry\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      // it may be possible the performance entry returned before detailed timing. If that's the case we should update\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      // assumptions and deal with mapping the entry back to the detailed timing here\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      performanceEntryChannels.updateChannelState(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        'recording',\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        () => new BoundedArray(MAX_CHANNEL_SIZE),\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      );\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    }\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  };\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  const unSubDetailedPointerTiming = setupDetailedPointerTimingListener(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    'pointer',\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      onComplete,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    },\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  );\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  const unSubDetailedKeyboardTiming = setupDetailedPointerTimingListener(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    'keyboard',\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      onComplete,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    },\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  );\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  const unSubInteractions = listenForPerformanceEntryInteractions(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    (completedInteraction) => {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      interactionStore.setState(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        BoundedArray.fromArray(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"          interactionStore.getCurrentState().concat(completedInteraction),\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"          MAX_INTERACTION_BATCH,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        ),\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      );\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    },\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  );\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  return () => {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubDirtyTaskTracking();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubLongPipelineTracking();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubPerformance();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubDetailedPointerTiming();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubInteractions();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubDetailedKeyboardTiming();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  };\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"};\"})})]})})}),`\n`,(0,e.jsx)(n.p,{children:\"Let\\u2019s go over this function in chunks.\"}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,e.jsxs)(n.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"const unSubPerformance = setupPerformancePublisher();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"const unSubDirtyTaskTracking = startDirtyTaskTracking();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"const unSubLongPipelineTracking = startLongPipelineTracking();\"})})]})})}),`\n`,(0,e.jsx)(n.p,{children:\"this calls three functions\\u200A\\u2014\\u200AsetupPerformancePublisher, startDirtyTaskTracking, startLongPipelineTracking.\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"startDirtyTaskTracking and startLongPipelineTracking are defined in the same event-tracking.ts file except for the setupPerformancePublisher which is imported from \",(0,e.jsx)(n.a,{href:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333\",children:\"core/notifications/performance.ts\"}),\".\"]}),`\n`,(0,e.jsxs)(n.blockquote,{children:[`\n`,(0,e.jsx)(n.p,{children:\"If there is one thing that I noticed, it is the cleanup involved across the react-scan codebase to avoid memory leaks.\"}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:(0,e.jsx)(n.img,{src:\"https://cdn-images-1.medium.com/max/1000/1*lzkeqQJsvALHF4CPpJrftQ.png\",alt:\"\"})}),`\n`,(0,e.jsx)(n.h3,{id:\"oncomplete-function\",children:\"onComplete function:\"}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,e.jsxs)(n.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"const onComplete = async (\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    _: string,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    finalInteraction: FinalInteraction,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    event: PerformanceEntryChannelEvent,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  ) => {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    toolbarEventStore.getState().actions.addEvent({\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      kind: 'interaction',\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      id: not_globally_unique_generateId(),\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      data: {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        startAt: finalInteraction.detailedTiming.blockingTimeStart,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        endAt: performance.now() + performance.timeOrigin,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        meta: { ...finalInteraction, kind: event.kind }, // TODO, will need interaction specific metadata here\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      },\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    });\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    const existingCompletedInteractions =\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      performanceEntryChannels.getChannelState('recording');\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    finalInteraction.detailedTiming.stopListeningForRenders();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    if (existingCompletedInteractions.length) {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      // then performance entry and our detailed timing handlers are out of sync, we disregard that entry\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      // it may be possible the performance entry returned before detailed timing. If that's the case we should update\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      // assumptions and deal with mapping the entry back to the detailed timing here\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      performanceEntryChannels.updateChannelState(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        'recording',\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        () => new BoundedArray(MAX_CHANNEL_SIZE),\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      );\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    }\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  };\"})})]})})}),`\n`,(0,e.jsx)(n.p,{children:\"this onComplete arrow function is defined in startTimingTracking. There\\u2019s an \\u201Cinteraction\\u201D event added and then there is this comment explaining what that if block is about:\"}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,e.jsxs)(n.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"// then performance entry and our detailed timing handlers are out of sync, we disregard that entry\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"// it may be possible the performance entry returned before detailed timing. If that's the case we should update\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"// assumptions and deal with mapping the entry back to the detailed timing here\"})})]})})}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,e.jsxs)(n.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"const unSubDetailedPointerTiming = setupDetailedPointerTimingListener(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    'pointer',\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      onComplete,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    },\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  );\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  const unSubDetailedKeyboardTiming = setupDetailedPointerTimingListener(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    'keyboard',\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      onComplete,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    },\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  );\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  const unSubInteractions = listenForPerformanceEntryInteractions(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    (completedInteraction) => {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      interactionStore.setState(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        BoundedArray.fromArray(\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"          interactionStore.getCurrentState().concat(completedInteraction),\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"          MAX_INTERACTION_BATCH,\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"        ),\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"      );\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    },\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  );\"})})]})})}),`\n`,(0,e.jsxs)(n.p,{children:[\"These 2 functions\\u200A\\u2014\\u200AsetupDetailedPointerTimingListener and listenForPerformanceEntryInteractions are defined in \",(0,e.jsx)(n.a,{href:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333\",children:\"performance.ts\"})]}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:(0,e.jsxs)(n.code,{\"data-language\":\"plaintext\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"return () => {\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubDirtyTaskTracking();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubLongPipelineTracking();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubPerformance();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubDetailedPointerTiming();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubInteractions();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"    unSubDetailedKeyboardTiming();\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{children:\"  };\"})})]})})}),`\n`,(0,e.jsx)(n.p,{children:\"This function in the end returns an arrow function that triggers unsubscription/cleanup.\"}),`\n`,(0,e.jsx)(n.h3,{id:\"about-me\",children:\"About me:\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"Hey, my name is \",(0,e.jsx)(n.a,{href:\"https://ramunarasinga.com\",children:\"Ramu Narasinga\"}),\". I study large open-source projects and create content about their codebase architecture and best practices, sharing it through articles, videos.\"]}),`\n`,(0,e.jsx)(n.p,{children:(0,e.jsx)(n.em,{children:(0,e.jsxs)(n.strong,{children:[\"I am open to work on interesting projects. Send me an email at \",(0,e.jsx)(n.a,{href:\"mailto:ramu.narasinga@gmail.com\",children:\"ramu.narasinga@gmail.com\"})]})})}),`\n`,(0,e.jsxs)(n.p,{children:[\"My Github\\u200A\\u2014\\u200A \",(0,e.jsx)(n.a,{href:\"https://github.com/ramu-narasinga\",children:\"https://github.com/ramu-narasinga\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"My website\\u200A\\u2014\\u200A \",(0,e.jsx)(n.a,{href:\"https://ramunarasinga.com/\",children:\"https://ramunarasinga.com\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"My Youtube channel\\u200A\\u2014\\u200A \",(0,e.jsx)(n.a,{href:\"https://www.youtube.com/@thinkthroo\",children:\"https://www.youtube.com/@thinkthroo\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Learning platform\\u200A\\u2014\\u200A \",(0,e.jsx)(n.a,{href:\"https://thinkthroo.com/\",children:\"https://thinkthroo.com\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Codebase Architecture\\u200A\\u2014\\u200A \",(0,e.jsx)(n.a,{href:\"https://app.thinkthroo.com/architecture\",children:\"https://app.thinkthroo.com/architecture\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Best practices\\u200A\\u2014\\u200A \",(0,e.jsx)(n.a,{href:\"https://app.thinkthroo.com/best-practices\",children:\"https://app.thinkthroo.com/best-practices\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Production-grade projects\\u200A\\u2014\\u200A \",(0,e.jsx)(n.a,{href:\"https://app.thinkthroo.com/production-grade-projects\",children:\"https://app.thinkthroo.com/production-grade-projects\"})]}),`\n`,(0,e.jsx)(n.h3,{id:\"references\",children:\"References:\"}),`\n`,(0,e.jsxs)(n.ol,{children:[`\n`,(0,e.jsxs)(n.li,{children:[`\n`,(0,e.jsx)(n.p,{children:(0,e.jsx)(n.a,{href:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L364\",children:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L364\"})}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[`\n`,(0,e.jsx)(n.p,{children:(0,e.jsx)(n.a,{href:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L365\",children:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L365\"})}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[`\n`,(0,e.jsx)(n.p,{children:(0,e.jsx)(n.a,{href:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L423\",children:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/event-tracking.ts#L423\"})}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[`\n`,(0,e.jsx)(n.p,{children:(0,e.jsx)(n.a,{href:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333\",children:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333\"})}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[`\n`,(0,e.jsx)(n.p,{children:(0,e.jsx)(n.a,{href:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333\",children:\"https://github.com/aidenybai/react-scan/blob/main/packages/scan/src/core/notifications/performance.ts#L333\"})}),`\n`]}),`\n`]})]})}function p(a={}){let{wrapper:n}=a.components||{};return n?(0,e.jsx)(n,{...a,children:(0,e.jsx)(h,{...a})}):h(a)}return k(S);})();\n;return Component;"
  },
  "_id": "blog/startTimingTracking-in-react.mdx",
  "_raw": {
    "sourceFilePath": "blog/startTimingTracking-in-react.mdx",
    "sourceFileName": "startTimingTracking-in-react.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/startTimingTracking-in-react"
  },
  "type": "Doc",
  "slug": "/blog/startTimingTracking-in-react",
  "slugAsParams": "startTimingTracking-in-react"
}